Everybody knows how a user resizes or moves a window:
    1. User "grabs" a side or corner of the window using the mouse
    2. User drags it to the size or position they want
    3. User releases the mouse and the window stops resizing.

Here's what Windows does behind the scenes to make this work:
    1. User clicks Window border/caption
        1) Send WM_NCHITTEST to determine where the click was, exactly.
        2) Send WM_NCLBUTTONDOWN with result from WM_NCHITTEST
            a. If WM_NCHITTEST result is HT_CAPTION, send WM_SYSCOMMAND with SC_MOVE.
            b. if WM_NCHITTEST result indicates a border click, send WM_SYSCOMMAND with SC_SIZE
        3) WM_SYSCOMMAND enters modal loop, blocking any GUI thread processing.
            i. Sends WM_GETMINMAXINFO to request minimum and maximum "tracking size" for Window.
            ii. Captures mouse input as if via SetCapture.
            iii. Sends WM_ENTERSIZEMOVE to indicate that the modal loop is entered.
    2. User moves mouse without releasing the mouse button (dragging the window)
        A) if SC_MOVE was sent with WM_SYSCOMMAND, the window is moved by the difference between the
            old cursor position and the new cursor position.
        B) if SC_SIZE was sent with WM_SYSCOMMAND
            i. a copy of the window rect is altered using the data
                gotten from WM_GETMINMAXINFO as limits.
            ii. this rect is sent along with WM_SIZING to give the window one last chance
                to change the new size of the window
            iii. the window is resized to the shape of this rect
        C) This modal behavior blocks GUI thread processing and low-priority events like WM_TIMER
    3. User releases mouse button
        1) Send WM_EXITSIZEMOVE to indicate that resizing as ended.
        2) Break from the modal loop.

How I do it:
    1. User clicks border/caption.
        1) Let DefWindowProc handle WM_NCHITTEST
        2) Customize sending of WM_SYSCOMMAND without breaking behavior from above.
        3) WM_SYSCOMMAND calls a function that:
            i. sets a thread local containing all necessary information
            ii. calls SetCapture to capture mouse input
            iii. sends WM_ENTERSIZEMOVE
            iv. returns without entering modal loop
    2. User drags window
        1) New function SizingCheck(const MSG *) must be called inside message loop
            i. handles all events messages for resize or move.
            ii. verifies the event actually calls for a resize or move.
            iii. performs all logic required for resize or move on thread local set above.
            iv. sends WM_SIZING with behavior consistent with above.
            v. changes window position or size using conventional User32 functions.
        2) This modeless behavior does not block GUI thread processing or WM_TIMER.
    3. User releases mouse button.
        1) Again, SizingCheck must be called inside the message loop.
            i. Releases mouse capture.
            ii. Windows sends WM_CAPTURECHANGED in response to ReleaseCapture
            iii. WM_CAPTURECHANGED handler sends WM_EXITSIZEMOVE and cleans up

The real code is a bit more complicated, both because of peculiarities in Windows Mouse Capture
    and because the mouse is not the only user input that can affect resizing or moving.
    But this describes it in detail enough that a good programmer should be able to figure out the rest.
For example, pressing the arrow keys provides the same effect as if the user had moved the cursor
    8px in the appropriate direction. Pressing return works the same as releasing the mouse.
    Pressing escape returns the window to its original size and position and stops the process, too.
