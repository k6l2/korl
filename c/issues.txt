[ ] KORL-ISSUE-000-000-004: maybe change the scissor parameters to be an integral data type, since at some point a rounding strategy must occur anyways, and this information is obscured by this API, just for the sake of making it easier to call with f32 data... Which, I don't know if that's a great tradeoff honestly.
[ ] KORL-ISSUE-000-000-005: simplify: is it possible to just have a "createRectangle" function, and then add texture or color components to it in later calls?  And if so, is this API good (benefits/detriments to usability/readability/performance?)? My initial thoughts on this are: (1) this would introduce unnecessary performance penalties since we cannot know ahead of time what memory to allocate for the batch (whether or not we need UVs, colors, etc.) (2) the resulting API might become more complex anyways, and increase friction for the user
[ ] KORL-ISSUE-000-000-012: add a cleanup function to verify that there are not memory leaks
[ ] KORL-ISSUE-000-000-014: move everything below this point into \c _Korl_Vulkan_SurfaceContext ???
[ ] KORL-ISSUE-000-000-015: store a collection of shader modules which can be referenced by external API, and store built-in shaders in known positions
[ ] KORL-ISSUE-000-000-017: do we REALLY not need device-local memory for this?  I don't trust the tutorial writer(s) about this.  Maybe this can be probed at some point.
[ ] KORL-ISSUE-000-000-018: I'm not actually making use of this state anywhere at the moment, so this is currently useless.
[ ] KORL-ISSUE-000-000-019: Vulkan; HACK: this is a really stupid way of making sure the allocator can handle depth image buffers.  Instead of doing it this way, we should have some way of iterating over all possible format combinations which could potentially be used with this allocator and create a dummy image for each combination.  If we don't remove this hack, we will always be limited to just one type of image buffer per allocator!
[ ] KORL-ISSUE-000-000-020: Vulkan; robustness: ensure that device objects respect `bufferImageGranularity`, obtained from `VkPhysicalDeviceLimits`, if we ever have NON-LINEAR device objects in the same allocation (in addition to respecting memory alignment requirements, of course).
[ ] KORL-ISSUE-000-000-021: polymorphic-tagged-union; We essentially need "virtual constructor/destructor" logic for this data type, since this logic is specific to the device object type (we need to use different Vulkan API for these tasks).It's worth noting that I have found this to be a common enough design pattern that at one point I created a simple C++ parser which automatically generated dispatch routines for virtual functions (kcpp?), which theoretically might make development of these constructs easier.  Although, I am not yet _entirely_ convinced that this is the case just yet.  Generated v-tables are not a panacea, and still don't properly solve issues associated with function pointer tables, such as hot code reloading, so such a feature might need a bit more effort to make it easy-to-use like C++ virtuals, but also not complete shit under the hood that we can't fix (like C++ virtuals).
[ ] KORL-ISSUE-000-000-023: add support for memory allocators to defragment pages.  This will probably require some kind of specialized API that calls back to the user of the allocator so that they can decide what to do with each allocation, since this behavior would be implementation-specific.  For example, if the allocator user is storing objects that have pointers (god help us) or something, they will need to manually re-assign them to the new de-fragmented values.
[ ] KORL-ISSUE-000-000-024: Vulkan; robustness: cross-check this list of extension names with the extensionProperties queried above to check if they are all provided by the platform
[ ] KORL-ISSUE-000-000-027: Vulkan; feature: add shader/pipeline resource API
[ ] KORL-ISSUE-000-000-029: pull out platform-agnostic code from platform-specific code module
[ ] KORL-ISSUE-000-000-030: redundant: technically we don't need this, since we can just call QueryVirtualMemoryInformation
[ ] KORL-ISSUE-000-000-031: copypasta: same code that runs in the `done` label (not sure if there is a good way to take this out though)
[ ] KORL-ISSUE-000-000-034: investigate: WM_PAINT, ValidateRect(hWnd, NULL); ???  I'm not actually sure if this is necessary, so maybe this is very low priority.
[~] KORL-ISSUE-000-000-036: (low priority) configure STB libs to not link to standard libraries at some point?  This should give us better stability & help clean up our application symbols in general
[ ] KORL-ISSUE-000-000-046: log: test to validate order of async log writes; we may or may not need to specify the offset to begin writing to the file for each async call, but I'm not sure.  See: https://stackoverflow.com/a/31787459
[ ] KORL-ISSUE-000-000-049: memory: logging an error when allocation fails in log module results in poor error logging
[ ] KORL-ISSUE-000-000-050: time: make time probe API thread-safe
[ ] KORL-ISSUE-000-000-054: file: I think we need to put a lock around context->asyncPool operations, since it is possible for multiple threads to attempt to read/write to this data simultaneously
[ ] KORL-ISSUE-000-000-057: file: initialization occurs before korl_crash_initialize, despite calling korl_assert & korl_log(ERROR)
[ ] KORL-ISSUE-000-000-060: Vulkan: test & verify driver version decoding on Intel+Windows; I only saw this code posted somewhere online, and I haven't actually tested it on real intel hardware
[ ] KORL-ISSUE-000-000-062: crash: minidump memory optimization/focus; this dump type results in HUGE dump files; is it possible to supply only a custom subset of memory regions to the dump?  I have tried MiniDumpWithPrivateReadWriteMemory, which seems to create smaller dumps, but sometimes the call to MiniDumpWriteDump fails, seemingly at random.  The MiniDumpWriteDump API seems to suggest that it is possible for the user to provide specific memory to include in the dump, which sounds pretty close to the ideal solution since we are managing almost all of our own memory, but I need to experiment a bit here to see if this is even possible.
[ ] KORL-ISSUE-000-000-066: memory: sort report allocations by ascending address
[ ] KORL-ISSUE-000-000-069: savestate/file: contain filesystem API to korl-file?
[ ] KORL-ISSUE-000-000-072: gfx/fontCache: glyph outlines don't utilize f32 accuracy of the outline thickness parameter; this also results in the glyph outlines always having a harsh (aliased) edge!
[ ] KORL-ISSUE-000-000-074: sort submodule: replace CRT calls with configurable macros
[ ] KORL-ISSUE-000-000-075: log: dump log buffer to debugger if configured to output logs to debugger
[ ] KORL-ISSUE-000-000-076: file: replace working with raw writable UTF-16 pointers, we need codepoint iteration/get/set API
[ ] KORL-ISSUE-000-000-077: crash/window: savestates do not properly "save" crashes that occur inside game module callbacks on window events; because we are not (de)serializing window events
[ ] KORL-ISSUE-000-000-078: prevent windows from going to sleep with no input; https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadexecutionstate?redirectedfrom=MSDN
[ ] KORL-ISSUE-000-000-081: savestate: weak/bad assumption; we currently rely on the fact that korl memory allocator handles remain the same between sessions.  Loading a savestate takes less logic, but the gain in performance/simplicity is negligible.  I would much rather have robust logic that is more guaranteed to assign the correct memory allocator handles (allocator handle (de)serialization)
[ ] KORL-ISSUE-000-000-082: memory: _korl_memory_getPersistentString is not thread-safe
[ ] KORL-ISSUE-000-000-083: gamepad: XBOX wireless devices only support a single gamepad instead of 4; IOCTL_XUSB_GET_STATE accepts a 3-byte input buffer, and in[2] appears to be a parameter indicating which controller we want to get the state of; my analysis of XInput disassembly has revealed that we might be able to use IOCTL_XUSB_GET_INFORMATION to query the XInput device for how many controllers it supports: it returns a 12-byte buffer, and out[2] _appears_ to contain the controllerCapacity of the device; I also suspect that out[1] contains the controllersConnected value, but more testing is required...
[ ] KORL-ISSUE-000-000-085: math: isNearlyEqualEpsilon code doesn't work and I don't know why; I had assumed that this worked but I need to investigate this again at some point
[ ] KORL-ISSUE-000-000-086: gfx: default font path doesn't work, since this subdirectly is unlikely in the game project
[ ] KORL-ISSUE-000-000-087: gfx: when FOV camera is pitched up/down at steep angles, there seems to be some weird stretching/squishing distortions, even at low FOV angles â˜¹
[ ] KORL-ISSUE-000-000-088: memory: currently, it is possible for general allocator to occupy page flags that lie outside the allocator's range of allocationPages; this is easily reproducible with a small allocator (64kB), 6 allocations that are 1 page or less total space, and 1 allocation that requires >= 3 pages!
[ ] KORL-ISSUE-000-000-089: vulkan-memory: log the program address space occupied by host-visible buffer memory maps
[ ] KORL-ISSUE-000-000-090: file: why did I have to change this 64=>128?  This feels so jank right now...
[ ] KORL-ISSUE-000-000-091: log: WARNING: the stb-ds module is initialized _after_ the log module; this is okay for now as far as I can tell since the stb-ds code can still function without the module being loaded, as all it does right now is just run unit tests, but this obviously not clean
[ ] KORL-ISSUE-000-000-092: vulkan: even though this technique _should_ make sure that the upcoming frame will have the correct pixel data, we are still not properly isolating texture memory from frames that are still WIP
[ ] KORL-ISSUE-000-000-093: log: if (!useLogFileAsync && useLogFileBig), we need to re-configure the log buffer to be "unlimited", since the log lines will not be dumped to the file until the program ends, ergo we need to guarantee that we store all log lines until this time, and a circular buffer will not accomplish this
[ ] KORL-ISSUE-000-000-094: gfx: font outlines using new Vulkan rendering APIs are not complete
[ ] KORL-ISSUE-000-000-095: bluetooth: maybe compare addresses instead of device names?
[ ] KORL-ISSUE-000-000-096: interface-platform, gfx: get rid of all "Vulkan" identifiers here; we don't want to expose the underlying renderer implementation to the user!
[ ] KORL-ISSUE-000-000-097: interface-platform, gfx: maybe just destroy Korl_Gfx_Batch & start over, since we've gotten rid of the concept of "batching" in the platform renderer; the primitive storage struct might also benefit from being a polymorphic tagged union
[ ] KORL-ISSUE-000-000-098: build: remove specialized configure scripts (korl-build-configure-debug/optimized/release), and use batch parameters on a single configure script instead (so we can do things like `config fast` instead of `config-fast`)
[~] KORL-ISSUE-000-000-100: math: apparently, all of the math datatypes are UB in C++11+; yikes!; https://stackoverflow.com/a/31080901/4526664
[ ] KORL-ISSUE-000-000-101: gfx: ASSUMPTION: viewport is the size of the entire window; if we ever want to handle separate viewport clip regions per-camera, we will have to modify this
[ ] KORL-ISSUE-000-000-102: gfx: testing required; ASSUMPTION: right-handed HC-space coordinate system that spans [0,1]; need to actually test to see if this works
[ ] KORL-ISSUE-000-000-103: vulkan: likely related to KORL-PERFORMANCE-000-000-041; refactor DrawState View & Projection to be M4f32; korl-vulkan shouldn't be concerned with how the user wants these transforms calculated
[ ] KORL-ISSUE-000-000-104: unicode, UTF-8, UTF-16: likely related to KORL-ISSUE-000-000-076; UTF-8 string codepoints can _not_ be randomly accessed via an array index (and for that matter, I think UTF-16 also has this issue?); the only way to properly access UTF-8 string characters is to use an iterator; I have been doing this incorrectly in many places, so my only hope is probably to just search for "utf8" in the code and meticulously fix everything...  Sorry, future me! ðŸ˜¶
[ ] KORL-ISSUE-000-000-105: window, configuration: detect invalid/corrupt configuration file, and maybe just save a fresh configuration file in this case
[~] KORL-ISSUE-000-000-106: window, configuration: we aren't detecting whether or not the window is "snapped" or "docked" to monitor corners; apparently this feature is difficult/impossible to do correctly (thanks, microshaft! ðŸ˜ ): https://stackoverflow.com/q/47888651/4526664
[ ] KORL-ISSUE-000-000-107: window: when we process a WM_MOVE event with wParam==SIZE_RESTORED, ensure that the window is never completely off-screen
[ ] KORL-ISSUE-000-000-108: window, configuration: separate configurations for different monitor setups
[ ] KORL-ISSUE-000-000-109: gui: there are a lot of similarities here to _getWidget; in an effort to generalize Window/Widget behavior, maybe I should just call _getWidget here???
[ ] KORL-ISSUE-000-000-110: gui: this is causing a leak of transient next widget modifiers!  _korl_gui_getWidget never gets called, which we currently expect to be the only place _korl_gui_resetTransientNextWidgetModifiers is called, ergo the next widget invocation will receive the modifiers intended for _this_ widget!!
[ ] KORL-ISSUE-000-000-111: gui: this sucks; is there a way for us to have korl-gui automatically determine how tall the text scroll area should be under the hood?  Use case: we want to fill the Y-axis space of a window with two widgets, and we want one of them to have a set size while the other one should fill all remaining space automatically
[ ] KORL-ISSUE-000-000-112: stringPool: incorrect grapheme detection; we are assuming 1 codepoint == 1 grapheme; in order to get true grapheme size, we have to detect unicode grapheme clusters; http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries; implementation example: https://stackoverflow.com/q/35962870/4526664; existing project which can achieve this (though, not sure about if it can be built in pure C, but the license seems permissive enough): https://github.com/unicode-org/icu, usage example: http://byronlai.com/jekyll/update/2014/03/20/unicode.html
[ ] KORL-ISSUE-000-000-113: windows-window: (minor) korl_clipboard_* API is being placed inside the korl-windows-window module due to the fact that we require a HWND to use these API on Windows; not sure if there is a better way to organize this...
[ ] KORL-ISSUE-000-000-116: gui: this does _not_ actually place the text position at the baseline!  This places the local origin at the bottom-left of the shrink-wrapped AABB; this causes the position of text to get jacked up when a glyph below the baseline is drawn (such as 'g' or 'j')
[ ] KORL-ISSUE-000-000-117: gui: don't we only want to do this logic if the activated window has changed?  not doing so is going to likely cause really annoying behavior such as the last window's leaf widget candidate always getting activated even when the window was already active :|
[ ] KORL-ISSUE-000-000-119: codec-configuration: rewrite UTF-8 decoder to use Utf8 iterators from korl-string
[ ] KORL-ISSUE-000-000-120: interface-platform: remove KORL_DEFINED_INTERFACE_PLATFORM_API; this it just messy imo; if there is clear separation of code that should only exist in the platform layer, then we should probably just physically separate it out into separate source file(s)
[ ] KORL-ISSUE-000-000-123: logConsole: fix box character rendering
[ ] KORL-ISSUE-000-000-124: logConsole: fix emoji rendering
[ ] KORL-ISSUE-000-000-125: sfx: long-term goal: support more surround-sound configurations; for now, it's more than fine to just support 2-channel stereo
[ ] KORL-ISSUE-000-000-127: (minor) array primitive data types should probably have `data` as the first member, and `size` as the second member... (not sure why I did it the other way around)
[ ] KORL-ISSUE-000-000-128: gui: (minor) WARNING logged on memory state load due to frivolous resource destruction; because we are calling `_korl_gui_getWidget` with a pointer to code-segment memory as the hash, the WIDGET_TEXT for the log console is different when a memory state is loaded; when memory state is loaded, the current session's WIDGET_TEXT is marked as `dirty`, since the loading of a memory state invalidates all multimedia transcodings of all resources; then, before `flushUpdates` is called, korl-gui destroys the old WIDGET_TEXT, which in turn destroys the resource which was marked `dirty`; this is wrong for the following reasons: (1) we should really refer to the exact same korl-gui widget in the logConsole code by hashing the widget `identifier` parameter, and since korl-gui state is being restored from the memory state, we should be guaranteed to have the exact same `uniqueId` for that widget's text resource handle
[ ] KORL-ISSUE-000-000-129: gfx/font: move all "FontCache" functionality into korl-resource, replace all "fontAssetName" strings in korl-gfx data structures with FONT Korl_Resource_Handles; this has gotten ridiculous: all the FontCache stuff should be managed by korl-resource because we need to be able to invalidate/reload this data properly when the underlying font asset is hot-reloaded, or when we load a memoryState or something; all the FontCache APIs should be `korl_resource_font_*` APIs, or something similar
[ ] KORL-ISSUE-000-000-130: gfx/font: (MAJOR) `fontCache->fontInfo` sets up pointers to data within `assetDataFont.data`; if that data ever moves or gets wiped (defragment, memoryState-load, etc.), then `fontCache->fontInfo` will contain dangling pointers!
[ ] KORL-ISSUE-000-000-131: file: make `korl_file_create` iterate over each directory separator & ensure the directory exists, then we can likely just delete `korl_file_directory_create`
[ ] KORL-ISSUE-000-000-133: heap: re-write GENERAL heap; the current implementation of GENERAL heap is needlessly complex, slow, & _buggy_
[ ] KORL-ISSUE-000-000-134: vulkan: add the ability to dynamically increase staging buffer arena capacity, as well as tune this initial value
[ ] KORL-ISSUE-000-000-135: resource: defragment transient resource data
[ ] KORL-ISSUE-000-000-136: memoryState: after loading a memory state, "serialized" allocator allocations have invalid meta->file pointers
[ ] KORL-PERFORMANCE-000-000-001: gfx: inefficient texture upload process; okay, I'm making a decision to just do the stupid method of "expanding" the 1-channel A8-format bitmap generated by stbtt into a R8G8B8A8-format image buffer, sending it off to vulkan, then destroying the temp buffer.  I'm just going to do this because for now I know it will work, and we can just come back to this if we ever encounter any performance issues!
[ ] KORL-PERFORMANCE-000-000-002: memory: you will never have a texture & font asset at the same time, so we could potentially overload this to the same string pointer
[ ] KORL-PERFORMANCE-000-000-003: memory: once again, only used by text batches; create a PTU here to save space?
[ ] KORL-PERFORMANCE-000-000-004: speed: most likely there is a MUCH more efficient way to build a matrix using these parameters
[ ] KORL-PERFORMANCE-000-000-005: speed: once again, not doing the most efficient thing here, but until this causes actual performance issues IDGAF
[ ] KORL-PERFORMANCE-000-000-006: speed: could potentially just compile this out for "release" builds, but like who actually cares??  The performance gain from doing so is most likely not at all worth it for all I know.  PRE-MATURE OPT!
[ ] KORL-PERFORMANCE-000-000-007: speed: comparisons between asset strings are going to be slow, so maybe we should create a hash table for asset identifiers at some point.  simple hash functions:  http://www.cse.yorku.ca/~oz/hash.html
[ ] KORL-PERFORMANCE-000-000-010: pre-calculate the ViewProjection matrix; probably good for performance, but I would like to do timings for this
[ ] KORL-PERFORMANCE-000-000-011: Vulkan; setting createInfoSampler.maxAnisotropy to a lower value will trade off performance for quality
[ ] KORL-PERFORMANCE-000-000-017: GFX; separate batch capacity with batch vertex/index counts themselves, allowing us to perform less reallocations (assuming this ever becomes a perf issue)
[ ] KORL-PERFORMANCE-000-000-018: GFX; (minor) use triangle fan primitive for less vertex indices
[ ] KORL-PERFORMANCE-000-000-021: Vulkan: this is better than what we were doing before, but optimally we would have no wait during batchFlushStaging at all
[ ] KORL-PERFORMANCE-000-000-025: stringPool: we should tell the allocation function that it doesn't have to sort
[ ] KORL-PERFORMANCE-000-000-027: memory: uncertain performance characteristics associated with re-committed pages; It is known that re-committing pages back and forth from the OS can be expensive.  An alternate strategy would be to give the OS a usage hint with VirtualAlloc(MEM_RESET), and conditionally zero the memory ourselves when we need to re-use this memory.  However, not even Raymond Chen knows whether or not this is faster:  https://devblogs.microsoft.com/oldnewthing/20170317-00/?p=95755.  That said, it can certainly be said that this technique is more complex, so I will leave this as performance research tech debt for now.
[ ] KORL-PERFORMANCE-000-000-028: memory: (likely extremely minor): _*general_enumerateAllocations: we should be able to skip more page flag registers immediately if we know we occupy 1 or more full registers
[ ] KORL-PERFORMANCE-000-000-029: memory: general allocator: occupiedPageOffset: Intuitively, I would assume that this code is just strictly sub-optimal, since we are just stupidly iterating over bit flags manually.  I feel like bitscans conducted on entire registers would be much more efficient.  However, I made an attempt at doing that here and either my code just sucks, or that technique was _actually_ sub-optimal (unlikely).  Alas, I am getting really sick of working on this code, so I am going to put this on the back-burner until performance ever becomes an issue in the future (if ever).
[ ] KORL-PERFORMANCE-000-000-030: memory: general allocator: does using bittest intrinsic result in better performance?  https://docs.microsoft.com/en-us/cpp/intrinsics/bittest-bittest64?view=msvc-170
[ ] KORL-PERFORMANCE-000-000-032: resource: stbi API unfortunately doesn't seem to have the ability for the user to provide their own allocator, so we need an extra alloc/copy/free here
[ ] KORL-PERFORMANCE-000-000-033: vulkan: potentially better device performance by removing these *_BUFFER bits, then adding a device-local vertex data pool to which we transfer all vertex data to
[ ] KORL-PERFORMANCE-000-000-034: vulkan: we could potentially get more performance here by removing HOST_COHERENT & manually calling vkFlushMappedMemoryRanges & vkInvalidateMappedMemoryRanges on bulk memory ranges; timings necessary
[ ] KORL-PERFORMANCE-000-000-035: vulkan: we could potentially get more performance here by transferring this data to device-local memory
[ ] KORL-PERFORMANCE-000-000-036: vulkan: if we allow interleaved vertex data, we can copy _everything_ to the staging buffer in a single memcopy operation!
[ ] KORL-PERFORMANCE-000-000-037: vulkan: it may or may not be better to handle descriptor pools similar to stbDaStagingBuffers (at the SurfaceContext level), and just fill each pool until it is full, then move onto the next pool, allocating more pools as-needed with frames sharing pools; theoretically this should lead to pools being reset less often, which intuitively seems like better performance to me...
[ ] KORL-PERFORMANCE-000-000-038: vulkan: MINOR; this could be faster if we pass the allocation itself, but this isn't really that important right now...
[ ] KORL-PERFORMANCE-000-000-039: gfx: apparently calculating kerning advance is _extremely_ expensive when the batch->_text is large; should this be an opt-in option to trade CPU time for font rendering accuracy?  In practice though, we really should _not_ be making huge text batches; we should always be using Gfx_Text objects for large amounts of text!  
[ ] KORL-PERFORMANCE-000-000-041: gfx: I expect this to be SLOW; we should instead be caching the camera's VP matrices and only update them when they are "dirty"; I know for a fact that SFML does this in its sf::camera class
[ ] KORL-PERFORMANCE-000-000-042: stringPool: aggressively nullifying other encodings; due to the fact that we don't have an internal API that wraps modifications to the raw string data from everything in this code module, it is difficult/impossible to lazy-free unused/dirty String encodings; ideally we would have a mechanism where if we, for example, convert a UTF-8 string to UTF-16, _both_ raw strings would be valid, eliminating the need for this module to perform the conversion multiple times if the user requires both encodings for different reasons, until the user decides to modify one of the encodings, thus invalidating the other encodings; until such a mechanism is in place, we have no choice but to invalidate all other encodings the moment a String is transcoded; we expect this to have poor performance in the above example, but at least it will be correct!
[ ] KORL-PERFORMANCE-000-000-045: gfx: (MAJOR) all drawing operations are being impacted by poor API design; the current API design was an attempt to make a SFML-like draw interface, where the user creates stand-alone "Drawable" data structures which can be either cached for later re-use, or used for a single frame at their leisure; the problem with this approach is that without any memory usage hints, the implementation has no choice but to invoke memory (re)allocations for each "Drawable" item, as well as a final memory_copy when the time comes that the user wants to actually issue the draw command itself; the reality is that memory (re)allocations & final memory_copy are completely unnecessary if the implementation is told ahead of time that the "Drawable" struct is only going to be used for one frame, and subsequently be discarded; in those scenarios, the gfx implementation could simply obtain staging memory from the renderer, allow the user to write the geometry data directly to the renderer staging memory, and be done with it
[ ] KORL-PERFORMANCE-000-000-046: assetCache: (memory) discard transient asset data as soon as it is transcoded; when I think about it, we really don't need to hold onto raw asset file data anymore once we have consumed/transcoded it into useful/useable data; we should make it so that when the user calls `korl_assetCache_get` & receives `KORL_ASSETCACHE_GET_RESULT_LOADED`, the transient asset could be marked for deletion & cleaned up at the end of the frame or something, since we're never going to use it again until the asset gets hot-reloaded, right?
[ ] KORL-PERFORMANCE-000-000-047: korl-stb-ds: (minor) `stbDsHashIndex->storage` is expected to be 64-bit-aligned, and it is unlikely to be aligned anymore
[x] KORL-PERFORMANCE-000-000-048: assetCache: (MAJOR) approx. 93% of the time spent in this entire function is inside korl_file_getDateStampLastWriteFileName; this wastes > 850Âµs of optimized build frame time; is it possible to perform this same functionality via async events with the OS?  https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
[ ] KORL-FEATURE-000-000-001: GFX: add support for outlined geometry (requires refactoring this API to use >= 1 sub-batches per Batch)
[ ] KORL-FEATURE-000-000-002: GFX: add support for outlined text (not sure how to do this with stbtt, maybe check how other implementations do this?); Technically this code works, but it's far too SLOW to be of use honestly.
[ ] KORL-FEATURE-000-000-004: GUI: automatically save window positions/sizes to a config file, and load them on startup
[ ] KORL-FEATURE-000-000-008: time: see if it's possible to use ETW in Windows to sample stack frames automatically for auto-generated profiling
[ ] KORL-FEATURE-000-000-009: time: display useful metrics in real-time using GUI or something
[ ] KORL-FEATURE-000-000-012: time: add C++ API layer for RAII time probe support
[ ] KORL-FEATURE-000-000-014: time: allow the user to filter the report display somehow to reduce clutter; perhaps allow the user to configure a maximum reported probe depth?  Or perhaps make probe categories or something?
[ ] KORL-FEATURE-000-000-015: crash: detect infinite loops (unresponsive program)
[ ] KORL-FEATURE-000-000-017: time: add ability to stash reports for later consumption; avoids the issue of not being able to probe the report itself, among other things
[ ] KORL-FEATURE-000-000-018: GUI: add API to check if the GUI has input focus
[ ] KORL-FEATURE-000-000-022: add job queue + worker threads
[ ] KORL-FEATURE-000-000-023: support GLTF assets (meshes, materials, animations, etc...)
[ ] KORL-FEATURE-000-000-024: gui/gfx: add DPI-awareness & support
[ ] KORL-FEATURE-000-000-025: add gamepad support; Resources: https://github.com/MysteriousJ/Joystick-Input-Examples, http://gyrowiki.jibbsmart.com/blog:finding-gravity-with-sensor-fusion.  Desired device support: XBOX360, XBONE, DS3, DS4, SwitchPro.  Desired input support: buttons, axes, touchPad, gyro/accel(sensor-fusion API?).  Desired output support: force-feedback.
[ ] KORL-FEATURE-000-000-026: add "create new project" script; new files: prompt script, minimal application.cpp; potentially create a new git repo & add KORL as a submodule
[ ] KORL-FEATURE-000-000-028: gui: display memory metrics, in potentially an interactable way
[ ] KORL-FEATURE-000-000-030: 3D collision detection
[ ] KORL-FEATURE-000-000-031: UDP networking
[ ] KORL-FEATURE-000-000-032: create sample/example projects
[ ] KORL-FEATURE-000-000-033: add testbed scripts using samples/examples
[ ] KORL-FEATURE-000-000-034: memory: automatically save allocator addresses to a config file & load them on startup (in development builds only probably?...); this will potentially help development debugging times a LOT in the long run!
[ ] KORL-FEATURE-000-000-035: add support for SIMD instruction sets (maybe something common, like SSE | AVX).  Resources: https://stackoverflow.com/a/22521619/4526664 https://www.intel.com/content/dam/develop/external/us/en/documents/36945 (specifically chapter 2.2)
[ ] KORL-FEATURE-000-000-036: gamepad: (low priority); expose gamepad deadzone values as configurable through the KORL platform interface
[ ] KORL-FEATURE-000-000-037: crash: enable floating point exceptions; I've already had one instance of a bug manifesting as a result of NAN f32 values being calculated accidentally
[ ] KORL-FEATURE-000-000-038: frame-by-frame stepping, as well as history scrubbing using savestate mechanism (just keep a circular buffer of savestates)
[ ] KORL-FEATURE-000-000-040: console; call commands, with tab-complete feature to make it easier
[ ] KORL-FEATURE-000-000-041: console; make load/save state a set of commands (with the name of the state file as a parameter)
[ ] KORL-FEATURE-000-000-042: memory: add "arena" abstraction to korl-memory allocators to support "infinite" memory capacity per allocator
[ ] KORL-FEATURE-000-000-043: vulkan: add ability to configure color; default color is RGBA; should this be more well-defined somewhere, such as a Korl_Vulkan_ColorChannel datatype or something?
[ ] KORL-FEATURE-000-000-044: vulkan: add ability to create batches, combining draw calls of a bunch of different pipelines; this could be done entirely on the GPU with transfer commands to device-local memory; related to KORL-PERFORMANCE-000-000-035
[ ] KORL-FEATURE-000-000-045: gui: add some kind of "style stack" API, and deprecate korl_gui_setFontAsset since it seems too inflexible
[ ] KORL-FEATURE-000-000-046: resource: right now it is very difficult to trace the owner of a resource; modify API to require FILE:LINE information for Resource allocations
[x] KORL-FEATURE-000-000-047: gui: text input widget
[x] KORL-ISSUE-000-000-000: lazy load asset if KORL_ASSETCACHE_GET_FLAG_LAZY is specified
[x] KORL-ISSUE-000-000-001: only assert that the file loaded when we're not lazy loading
[x] KORL-ISSUE-000-000-002: VERY primitive implementation of `isVisibleCharacter`; we should just be using stbtt_IsGlyphEmpty for this purpose
[x] KORL-ISSUE-000-000-003: robustness: this is the "quick & dirty" stbtt API, ergo it's probably a good idea to switch to the lower-level API to be able to do things like lazy glyph caching, better packing, outlines, etc...
[x] KORL-ISSUE-000-000-006: GUI: switch to use of a strong hash function instead of pointer; so for now, I'm just going to hash the identifier strings passed to window/widget API with an internal "loop counter", which allows us to create widgets with the same identifier inside of a for loop, for example;  in other words, I'm not sure how useful it would be to hash the actual window/widget identifier strings instead of just using their pointer addresses like we're doing right now
[x] KORL-ISSUE-000-000-007: do we need to reassign the order of the widgets for the current window?  I wont bother with this until I learn a little bit about API usage...
[x] KORL-ISSUE-000-000-008: instead of using the AABB of this text batch, we should be using the font's metrics!  Probably??  Different text batches of the same font will yield different sizes here, which will cause widget sizes to vary...
[x] KORL-ISSUE-000-000-009: I have no idea why, but the Vulkan renderer is not drawing the upper-left corner of the window border correctly, so the first line's x-coordinate is offset by a half pixel
[x] KORL-ISSUE-000-000-010: memory allocator API: we don't actually need to expose ANY of this allocator API right now for any reason - all the user of this module needs is the enumeration of what kind of allocator they are getting, then the dispatch can just all be done internally and the user doesn't have to deal with function pointer crap.  In addition, we do NOT want the application storing any pointers!  We want to just store a handle to an allocator which is managed by the OS layer!
[x] KORL-ISSUE-000-000-011: simplify: make some macros which automatically inject file + line for calls to these allocator functions so we don't have to think about it
[x] KORL-ISSUE-000-000-013: add blend equations
[x] KORL-ISSUE-000-000-016: robustness: use KORL_MEMORY_POOL_* API, or something similar
[x] KORL-ISSUE-000-000-022: add support for memory allocators to decommit pages which are no longer in use
[-] KORL-ISSUE-000-000-025: Vulkan; re-record command buffers?... (waste of time probably)
[x] KORL-ISSUE-000-000-026: consistency: rename to Korl_Vulkan_Color3u8
[x] KORL-ISSUE-000-000-028: In the case that we're deploying this application (not running in a debugger) maybe do one or more of the following things: (1) offer a choice to continue execution (2) offer a choice to write a memory dump to disk
[x] KORL-ISSUE-000-000-032: safety: ensure that the thread calling this function is the main thread to ensure that the function pointers of the Korl_Memory_Allocator will always be valid, since the main program module (should) never be reloaded
[x] KORL-ISSUE-000-000-033: do we actually need `strsafe.h`?  This API seems to suck ass compared to the stuff it supposedly "replaced", such as \c _vscwprintf & \c vswprintf_s
[x] KORL-ISSUE-000-000-035: hack: delete this scaffolding once we have application/KORL separation at the project level
[x] KORL-ISSUE-000-000-037: remove C++20 flag from compile when game module is separate translation unit
[x] KORL-ISSUE-000-000-038: GUI: text AABBs are not being calculated correctly.  Example: try making a text widget that displays "[E][S][D][F]".  Observed behavior: the calculated AABB includes nothing below the text baseline it seems?...
[x] KORL-ISSUE-000-000-039: GUI: text AABBs are not being calculated correctly.  Example: make a text widget with just hashes ("---------") above & below other text widgets.  Expected behavior: whitespace above & below the hash characters.  Observed behavior: font metrics are not taken into account; no whitespace is taken into account for spacing between the widgets.
[x] KORL-ISSUE-000-000-040: interface-game-memory: because this file is included in the platform's C translation unit, we can't declare/define any C++ datatypes here (such as classes).  Is this something to be concerned about?...
[x] KORL-ISSUE-000-000-041: build: remove exception handling code generation from platform translation unit, once the game translation unit is separated
[x] KORL-ISSUE-000-000-042: fix the issue with all the %s formatted strings being WRONG in the platform layer!!! (excluding: **\stb, submodules/korl/code)  I'm not sure what caused this, but I should probably finish the log refactor branch first before fixing this issue...
[x] KORL-ISSUE-000-000-043: memory: when allocations fail, log a warning & return NULL instead of failing an assert
[x] KORL-ISSUE-000-000-044: build: for deployments, consider using /ZH:SHA_256 to generate more robust PDB hashes
[x] KORL-ISSUE-000-000-045: windows: pass window focus state to game module; https://stackoverflow.com/a/466372
[x] KORL-ISSUE-000-000-047: build: separate game & platform module translation units into their own commands to allow separate compilation options & potentially multithreaded builds
[x] KORL-ISSUE-000-000-048: build: configure "release" build mode to test more optimized code, so we can actually benchmark stuff
[x] KORL-ISSUE-000-000-051: countFormatSubstitutions: take precision '*' into account
[x] KORL-ISSUE-000-000-052: log: potentially unnecessary allocator; unfortunately, due to how primitive linear allocators are, we can't throw all the allocations we're doing into the same allocator because when the big log circular buffer reallocs, the transient buffers (used for async file I/O, etc) will continuously push the big buffer higher up, further fragmenting memory until we run out of space!  To use a single allocator, we need to either add allocator defragmentation capabilities or implement a better realloc strategy that can look backwards as well as forwards (perhaps as a different allocator type?)
[x] KORL-ISSUE-000-000-053: memory: allow this API to work on other threads (IMPORTANT: this might be needed for log module!)
[x] KORL-ISSUE-000-000-055: file: deprecate this API because it sucks; _korl_file_getPath seems so much better
[x] KORL-ISSUE-000-000-056: assert: this code is extremely similar to code inside of korl-crash; maybe merge korl-assert into korl-crash?
[x] KORL-ISSUE-000-000-058: math: F32_MIN doesn't seem right
[-] KORL-ISSUE-000-000-059: window: find a frame timing solution that works if vulkan API blocks for some reason; on my machine at least, this ONLY works correctly for VK_PRESENT_MODE_MAILBOX_KHR present mode (apparently this is no longer an issue after updating my NVIDIA drivers...)
[-] KORL-ISSUE-000-000-061: crash: we don't have to generate an exception to create a minidump (but actually, according to MSDN at least, this is a valid strategy to at least guarantee a readable stack state in the resulting minidump)
[x] KORL-ISSUE-000-000-063: crash: running MessageBox on the same thread as the the game window still allows window messages to be processed, causing all sorts of shenanigans to occur; for example, if a crash happens in any input event, and another input event fires when the modal crash dialog is presented, another crash will be generated during exception handling, causing the application to unexpectedly close; is there a way to display a user interface like this without giving any other code on the failed process to run?  My ideal solution would be to somehow pause all activity on all threads when an unhandled/illegal exception is caught, and maybe running the dialog box on another process or something so that it can't interfere with the contaminated process state.  Raymond Chen with an example of using "toolhelp snapshots": https://devblogs.microsoft.com/oldnewthing/20060223-14/?p=32173; would this be useful in resolving this issue?  Thread-walking API: https://docs.microsoft.com/en-us/windows/win32/toolhelp/thread-walking?redirectedfrom=MSDN  Origin stack-overflow query: https://stackoverflow.com/questions/17334225/how-to-get-list-of-thread-ids-for-current-process  SuspendThread MSDN doc: https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread; I am just solving this for now by adding an early-out bool check at the top of the window handler which ignores all messages during a crash
[-] KORL-ISSUE-000-000-064: Vulkan: get rid of WIP frames? https://www.reddit.com/r/vulkan/comments/pq2679/understanding_queuing_multiple_frames_at_a_time/; https://www.reddit.com/r/vulkan/comments/jtuhmu/synchronizing_frames_in_flight/; all that really matters here is that we don't have to perform unnecessary fence waiting each swap chain image acquisition operation at the start of each frame, not necessarily that we need to get rid of "wipFrames"
[x] KORL-ISSUE-000-000-065: log: although this is generally safe for current workloads, this operation is unsafe for async log file writes
[x] KORL-ISSUE-000-000-067: load-save-state: allocation file name not supported; when re-creating savestate allocations, we cannot specify the file name, because these are just stored in the allocators as a shallow address (we do not do a deep copy of the file name string!)
[x] KORL-ISSUE-000-000-068: window: maybe expose more general API for doing things like save/load states & generate profiling reports
[x] KORL-ISSUE-000-000-070: gfx/fontCache: Either cache glyphs dynamically instead of a fixed region all at once, or devise some way to configure the pre-cached range.
[x] KORL-ISSUE-000-000-071: vulkan-memory: linear allocation addresses are vulnerable to fragmentation; if we continuously allocate device memory objects, we will quickly run out of addresses!  perhaps we can recycle unused device memory addresses in the allocate functions?
[x] KORL-ISSUE-000-000-073: gui: widgets do not get ordered properly when they do not get "created" each frame; the recreated widget will get put at the bottom of the window's list of widgets, when the expected behavior is for the widgets to maintain the exact same order as they were created
[x] KORL-ISSUE-000-000-079: stringPool/file/savestate: either create a (de)serialization API for stringPool, or just put context state into a single allocation?  Although, why am I trying to push towards supporting fully properly "packed" savestate binary data anyways?  Since this mechanism inherently relies on raw memory copies, we will never be able to support cross-memory-architecture anyways, so all the effort spent to properly "pack" data into savestates is wasted...
[x] KORL-ISSUE-000-000-080: memory: korl_heap_linear_enumerateAllocations can't properly early-out if the enumeration callback returns false
[-] KORL-ISSUE-000-000-084: gamepad: (low priority) XBOX controller guide button is not being captured; it is possible to use secret undocumented API to obtain this button value; see: https://forums.tigsource.com/index.php?topic=26792.msg848190#msg848190 https://github.com/DieKatzchen/GuideButtonPoller
[x] KORL-ISSUE-000-000-099: windows-window: window "maximized" state is not preserved when loading a memory state; use GetWindowPlacement API to get this state from the window
[x] KORL-ISSUE-000-000-114: stringPool: we should pass the String address here so we can invalidate the data for the user
[x] KORL-ISSUE-000-000-115: platform-api: remove all these string functions from platform API; move them all to korl-string (except maybe platform-specific implementations, like C string formatting)
[x] KORL-ISSUE-000-000-118: gui: figure out why the console text disappears after the "attempted batch is empty" warning is spammed enough
[x] KORL-ISSUE-000-000-121: command/memory-state: loading a memory state that contains registered command(s) that no longer exist will cause assert to fire
[x] KORL-ISSUE-000-000-122: logConsole: fix '\t' character rendering
[x] KORL-ISSUE-000-000-126: sfx: after loading a memory state, looping Tapes are invalidated & causes bugs (such as Tape leaks; causes infinite looping overlapping incorrect Tapes to play forever)
[x] KORL-ISSUE-000-000-132: heap: multi-threading hazard; in order to use uniform context with this sort API on multiple threads, we would need to use thread-local storage or something
[x] KORL-PERFORMANCE-000-000-000: (minor) these pointers all reference contiguous memory regions which immediately follow this struct itself, ergo can be converted to offsets, saving us space but making the code less readable
[x] KORL-PERFORMANCE-000-000-008: even if we do end up needing to store the asset strings, it would likely be better if we store the strings in a separate string pool, and store a handle to that string here for faster iteration over device assets - we're wasting like an entire cache line per device asset lol
[x] KORL-PERFORMANCE-000-000-009: pass model as push constant instead?  Timings required.
[x] KORL-PERFORMANCE-000-000-012: Vulkan; bandwidth: (MAJOR!) this is very heavy handed!  It would be better if this process could happen in the background while we wait on a fence or something so that the graphicsQueue can keep going unimpeded and program execution can continue batching more vertices.
[x] KORL-PERFORMANCE-000-000-013: Vulkan; speed: binding descriptor sets is an expensive operation, and it's likely that we will not need to do so each time the batch pipeline is flushed
[x] KORL-PERFORMANCE-000-000-014: Vulkan; bandwidth: we don't actually need to submit this buffer right now!  It should be possible to maintain a command buffer for at least the duration of a frame (if not > 1 frame), and ONLY submit/flush the commands once any of the following conditions are met:  (1) the staging asset buffer fills up (2) we reach the end of the frame & the staging asset buffer is NOT empty
[x] KORL-PERFORMANCE-000-000-015: Vulkan; we're shoving all the descriptors necessary for our batch rendering into a single descriptor set, but it's likely that some of the descriptors will have to change much more frequently during a frame, ergo, it is likely that splitting this descriptor set layout into multiple, and consequently having multiple descriptor sets for batch rendering per frame, will end up being more efficient
[x] KORL-PERFORMANCE-000-000-016: Vulkan; speed: this is stupid & obviously slow; consider storing texture assets in a fixed-size table, allowing constant time lookups for each handle
[x] KORL-PERFORMANCE-000-000-019: build: investigate potential benefits of running the platform/game translation units on separate threads
[x] KORL-PERFORMANCE-000-000-020: Vulkan: (MAJOR!) reduce batch descriptor set flush frequency; we should intelligently look at the last known state (for things like texture handle, etc) and ONLY flush batch descriptor sets if this changes, instead of ALWAYS flushing
[x] KORL-PERFORMANCE-000-000-022: Vulkan: (minor) this function currently assumes that the caller is expecting to be able to safely write to the new staging buffer RIGHT AWAY, but in this special case we do NOT need to wait for the alternate staging buffer to be available!!!  We should add a parameter to this function to optionally ignore the `wait_for_new_buffer_fence` code that runs at the end of this function.
[x] KORL-PERFORMANCE-000-000-023: Vulkan: (20us per iteration) likely suboptimal use of Vulkan synchronization primitives
[x] KORL-PERFORMANCE-000-000-024: Log: (likely MAJOR): Can we get away with just not doing any transient buffer allcations (just use the primary buffer + circular buffer)?  Currently, our Linear allocation strategy is heavy-handed, sacrificing speed for safety.  This is to the point that I've noticed individual allocations can take upwards of 20-40us.  This is fine for one-off allocations here and there, but logs are generated all over the place right now.  I highly suspect that this is the vast majority of time loss in places that are pumping out tons of logs, such as for time probe reports!
[x] KORL-PERFORMANCE-000-000-026: savestate/assetCache: there is no need to save/load every asset; we only need assets that have been flagged as "operation critical" (where "operation critical" means that the asset data is required for correct application behavior given memory state & user inputs)
[x] KORL-PERFORMANCE-000-000-031: gfx, fontCache: using a hash map as a lookup table for baked glyphs might be faster
[x] KORL-PERFORMANCE-000-000-040: gui: MEDIUM-MAJOR; attempt to completely remove the necessity to call _korl_gui_processWidgetGraphics two times inside korl_gui_frameEnd, and remove the second parameter for that matter
[x] KORL-PERFORMANCE-000-000-043: heap: (MAJOR) _all_ hot code paths are being _greatly_ inhibited by heap `PageGuard` functionality; we might be much better off settling on allocators which do _not_ use guard pages (maybe in the future this could be a debug-only safety validation switch) by default, and instead we opt for simple `sentinel data` validation at runtime, perhaps only at the top/bottom of the frame; I suspect that such a scheme will be _significantly_ faster, and still provide a ton of heap corruption protection/detection; we probably also want to commit memory pages _sparingly_ for similar reasons (these windows kernel-mode APIs are just too insanely slow)
[x] KORL-PERFORMANCE-000-000-044: file: (MAJOR) creation of memory state is lighting up due to calls to `memcpy`; research is needed here: is this due to excessive # of calls, or just the act of copying memory itself?; if it's the former, the solution might involve collating serialized heaps, we could even theoretically copy the entire memory state with a single `memcpy` call; if it's the latter, we might be boned, as it could be entirely possible that copying all this memory for each frame is just infeasible/impossible
[x] KORL-FEATURE-000-000-000: add vectored exception handler so we can generate crash dumps & flush logs
[-] KORL-FEATURE-000-000-003: interface-game-memory, memory: IMPORTANT!!!  Create the concept of "allocation handles" that come from korl-memory allocators.  This will allow us to effectively store pointers to dynamically allocated memory which can persist between game/application "states"!  Without this, we would not be able to easily implement save/load state features, which in turn will prevent us from having the ideal of "true" memory dumps, which can be generated at the beginning of each frame, saved when the application crashes, & loaded at another time on another computer for debug analysis.  Well actually, now that I'm thinking about it, shouldn't this be fine?  Since our memory dumps will capture the entire state of the KORL allocators, including what range of virtual memory they occupy, it should be entirely possible to reconstruct the complete state of memory contained within the allocators, which in turn will place objects referred to by pointers at the exact location in memory that they orignally occupied!  Except, NO.  This does not account for tons of data that is contained in data segments of program memory.  Any pointers, or even data, held in this region are fucked if you load a save-state.  For example: in assetCache, we have a pool of AssetData, which in turn contain pointers to raw asset data buffers.  Not only will these data buffer pointers become invalid in a load-state scenario, but the database itself is subject to change - we do _not_ actually know what assets were loaded in the assetCache in the save-state!  After brainstorming a bit, I can't really think of a good way to do this without doing something dumb like hash table lookups, which seem completely unnecessary, so I'm just going to rectify this by individually serializing pointers & data outside of allocators on a case-by-case basis, and we'll just have to see how maintainable that is over time...
[x] KORL-FEATURE-000-000-005: GUI: allow user to call widget API & have a window automatically created for them
[x] KORL-FEATURE-000-000-006: save/load application state (REAL memory dumps)
[x] KORL-FEATURE-000-000-007: dynamic resizing arrays, similar to stb_ds, but maybe configurable with a custom KORL allocator per array?
[x] KORL-FEATURE-000-000-010: game: support automatic hot-reloading of entire code module
[x] KORL-FEATURE-000-000-011: math: add C++ API layer for operator overloading support
[x] KORL-FEATURE-000-000-013: time: report total time probe count in the report
[x] KORL-FEATURE-000-000-016: window: limit & regulate frame rate
[x] KORL-FEATURE-000-000-019: window: automatically save window position/size to a config file, and load them on startup
[x] KORL-FEATURE-000-000-020: crash: dump savestate on crash
[x] KORL-FEATURE-000-000-021: assetCache: automatic hot-reloading of assets
[x] KORL-FEATURE-000-000-027: [DUPLICATE OF KORL-FEATURE-000-000-009] gui: display time probe metrics, in potentially an interactable way
[x] KORL-FEATURE-000-000-029: add audio support; maybe use WASAPI & a mixer layer?  Desired support: WAVE files, OGG/Vorbis files.
[x] KORL-FEATURE-000-000-039: console; display logs in real-time; do _not_ display the meta data content, only display a subset of the meta data of each log line if the user mouses over the log entry; color-code log entries based on their log level
