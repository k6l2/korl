[ ] KORL-ISSUE-000-000-000: lazy load asset if KORL_ASSETCACHE_GET_FLAGS_LAZY is specified
[ ] KORL-ISSUE-000-000-001: only assert that the file loaded when we're not lazy loading
[ ] KORL-ISSUE-000-000-002: VERY primitive implementation of `isVisibleCharacter`
[ ] KORL-ISSUE-000-000-003: robustness: this is the "quick & dirty" stbtt API, ergo it's probably a good idea to switch to the lower-level API to be able to do things like lazy glyph caching, better packing, outlines, etc...
[ ] KORL-ISSUE-000-000-004: maybe change the scissor parameters to be an integral data type, since at some point a rounding strategy must occur anyways, and this information is obscured by this API, just for the sake of making it easier to call with f32 data... Which, I don't know if that's a great tradeoff honestly.
[ ] KORL-ISSUE-000-000-005: simplify: is it possible to just have a "createRectangle" function, and then add texture or color components to it in later calls?  And if so, is this API good (benefits/detriments to usability/readability/performance?)? My initial thoughts on this are: (1) this would introduce unnecessary performance penalties since we cannot know ahead of time what memory to allocate for the batch (whether or not we need UVs, colors, etc.) (2) the resulting API might become more complex anyways, and increase friction for the user
[ ] KORL-ISSUE-000-000-006: switch to use of a strong hash function instead of pointer
[ ] KORL-ISSUE-000-000-007: do we need to reassign the order of the widgets for the current window?  I wont bother with this until I learn a little bit about API usage...
[ ] KORL-ISSUE-000-000-008: instead of using the AABB of this text batch, we should be using the font's metrics!  Probably??  Different text batches of the same font will yield different sizes here, which will cause widget sizes to vary...
[ ] KORL-ISSUE-000-000-009: I have no idea why, but the Vulkan renderer is not drawing the upper-left corner of the window border correctly, so the first line's x-coordinate is offset by a half pixel
[x] KORL-ISSUE-000-000-010: memory allocator API: we don't actually need to expose ANY of this allocator API right now for any reason - all the user of this module needs is the enumeration of what kind of allocator they are getting, then the dispatch can just all be done internally and the user doesn't have to deal with function pointer crap.  In addition, we do NOT want the application storing any pointers!  We want to just store a handle to an allocator which is managed by the OS layer!
[x] KORL-ISSUE-000-000-011: simplify: make some macros which automatically inject file + line for calls to these allocator functions so we don't have to think about it
[ ] KORL-ISSUE-000-000-012: add a cleanup function to verify that there are not memory leaks
[ ] KORL-ISSUE-000-000-013: add blend equations
[ ] KORL-ISSUE-000-000-014: move everything below this point into \c _Korl_Vulkan_SurfaceContext ???
[ ] KORL-ISSUE-000-000-015: store a collection of shader modules which can be referenced by external API, and store built-in shaders in known positions
[ ] KORL-ISSUE-000-000-016: robustness: use KORL_MEMORY_POOL_* API, or something similar
[ ] KORL-ISSUE-000-000-017: do we REALLY not need device-local memory for this?  I don't trust the tutorial writer(s) about this.  Maybe this can be probed at some point.
[ ] KORL-ISSUE-000-000-018: I'm not actually making use of this state anywhere at the moment, so this is currently useless.
[ ] KORL-ISSUE-000-000-019: Vulkan; HACK: this is a really stupid way of making sure the allocator can handle depth image buffers.  Instead of doing it this way, we should have some way of iterating over all possible format combinations which could potentially be used with this allocator and create a dummy image for each combination.  If we don't remove this hack, we will always be limited to just one type of image buffer per allocator!
[ ] KORL-ISSUE-000-000-020: Vulkan; robustness: ensure that device objects respect `bufferImageGranularity`, obtained from `VkPhysicalDeviceLimits`, if we ever have NON-LINEAR device objects in the same allocation (in addition to respecting memory alignment requirements, of course).
[ ] KORL-ISSUE-000-000-021: polymorphic-tagged-union; We essentially need "virtual constructor/destructor" logic for this data type, since this logic is specific to the device object type (we need to use different Vulkan API for these tasks).It's worth noting that I have found this to be a common enough design pattern that at one point I created a simple C++ parser which automatically generated dispatch routines for virtual functions (kcpp?), which theoretically might make development of these constructs easier.  Although, I am not yet _entirely_ convinced that this is the case just yet.  Generated v-tables are not a panacea, and still don't properly solve issues associated with function pointer tables, such as hot code reloading, so such a feature might need a bit more effort to make it easy-to-use like C++ virtuals, but also not complete shit under the hood that we can't fix (like C++ virtuals).
[ ] KORL-ISSUE-000-000-022: add support for memory allocators to decommit pages which are no longer in use
[ ] KORL-ISSUE-000-000-023: add support for memory allocators to defragment pages.  This will probably require some kind of specialized API that calls back to the user of the allocator so that they can decide what to do with each allocation, since this behavior would be implementation-specific.  For example, if the allocator user is storing objects that have pointers (god help us) or something, they will need to manually re-assign them to the new de-fragmented values.
[ ] KORL-ISSUE-000-000-024: Vulkan; robustness: cross-check this list of extension names with the extensionProperties queried above to check if they are all provided by the platform
[ ] KORL-ISSUE-000-000-025: Vulkan; re-record command buffers?... (waste of time probably)
[ ] KORL-ISSUE-000-000-026: consistency: rename to Korl_Vulkan_Color3u8
[ ] KORL-ISSUE-000-000-027: Vulkan; feature: add shader/pipeline resource API
[ ] KORL-ISSUE-000-000-028: In the case that we're deploying this application (not running in a debugger) maybe do one or more of the following things: (1) offer a choice to continue execution (2) offer a choice to write a memory dump to disk
[ ] KORL-ISSUE-000-000-029: pull out platform-agnostic code from platform-specific code module
[ ] KORL-ISSUE-000-000-030: redundant: technically we don't need this, since we can just call QueryVirtualMemoryInformation
[ ] KORL-ISSUE-000-000-031: copypasta: same code that runs in the `done` label (not sure if there is a good way to take this out though)
[x] KORL-ISSUE-000-000-032: safety: ensure that the thread calling this function is the main thread to ensure that the function pointers of the Korl_Memory_Allocator will always be valid, since the main program module (should) never be reloaded
[x] KORL-ISSUE-000-000-033: do we actually need `strsafe.h`?  This API seems to suck ass compared to the stuff it supposedly "replaced", such as \c _vscwprintf & \c vswprintf_s
[ ] KORL-ISSUE-000-000-034: investigate: WM_PAINT, ValidateRect(hWnd, NULL); ???  I'm not actually sure if this is necessary, so maybe this is very low priority.
[ ] KORL-ISSUE-000-000-035: hack: delete this scaffolding once we have application/KORL separation at the project level
[ ] KORL-ISSUE-000-000-036: (low priority) configure STB libs to not link to standard libraries at some point?  This should give us better stability & help clean up our application symbols in general
[ ] KORL-ISSUE-000-000-037: remove C++20 flag from compile when game module is separate translation unit
[ ] KORL-ISSUE-000-000-038: GUI: text AABBs are not being calculated correctly.  Example: try making a text widget that displays "[E][S][D][F]".  Observed behavior: the calculated AABB includes nothing below the text baseline it seems?...
[ ] KORL-ISSUE-000-000-039: GUI: text AABBs are not being calculated correctly.  Example: make a text widget with just hashes ("---------") above & below other text widgets.  Expected behavior: whitespace above & below the hash characters.  Observed behavior: font metrics are not taken into account; no whitespace is taken into account for spacing between the widgets.
[ ] KORL-ISSUE-000-000-040: interface-game-memory: because this file is included in the platform's C translation unit, we can't declare/define any C++ datatypes here (such as classes).  Is this something to be concerned about?...
[ ] KORL-ISSUE-000-000-041: build: remove exception handling code generation from platform translation unit, once the game translation unit is separated
[ ] KORL-PERFORMANCE-000-000-000: MINOR - these pointers all reference contiguous memory regions which immediately follow this struct itself, ergo can be converted to offsets, saving us space but making the code less readable
[ ] KORL-PERFORMANCE-000-000-001: okay, I'm making a decision to just do the stupid method of "expanding" the 1-channel A8-format bitmap generated by stbtt into a R8G8B8A8-format image buffer, sending it off to vulkan, then destroying the temp buffer.  I'm just going to do this because for now I know it will work, and we can just come back to this if we ever encounter any performance issues!
[ ] KORL-PERFORMANCE-000-000-002: memory: you will never have a texture & font asset at the same time, so we could potentially overload this to the same string pointer
[ ] KORL-PERFORMANCE-000-000-003: memory: once again, only used by text batches; create a PTU here to save space?
[ ] KORL-PERFORMANCE-000-000-004: speed: most likely there is a MUCH more efficient way to build a matrix using these parameters
[ ] KORL-PERFORMANCE-000-000-005: speed: once again, not doing the most efficient thing here, but until this causes actual performance issues IDGAF
[ ] KORL-PERFORMANCE-000-000-006: speed: could potentially just compile this out for "release" builds, but like who actually cares??  The performance gain from doing so is most likely not at all worth it for all I know.  PRE-MATURE OPT!
[ ] KORL-PERFORMANCE-000-000-007: speed: comparisons between asset strings are going to be slow, so maybe we should create a hash table for asset identifiers at some point.  simple hash functions:  http://www.cse.yorku.ca/~oz/hash.html
[ ] KORL-PERFORMANCE-000-000-008: even if we do end up needing to store the asset strings, it would likely be better if we store the strings in a separate string pool, and store a handle to that string here for faster iteration over device assets - we're wasting like an entire cache line per device asset lol
[ ] KORL-PERFORMANCE-000-000-009: pass model as push constant instead?  Timings required.
[ ] KORL-PERFORMANCE-000-000-010: pre-calculate the ViewProjection matrix; probably good for performance, but I would like to do timings for this
[ ] KORL-PERFORMANCE-000-000-011: Vulkan; setting createInfoSampler.maxAnisotropy to a lower value will trade off performance for quality
[ ] KORL-PERFORMANCE-000-000-012: Vulkan; bandwidth: this is very heavy handed!  It would be better if this process could happen in the background while we wait on a fence or something so that the graphicsQueue can keep going unimpeded and program execution can continue batching more vertices.
[ ] KORL-PERFORMANCE-000-000-013: Vulkan; speed: binding descriptor sets is an expensive operation, and it's likely that we will not need to do so each time the batch pipeline is flushed
[ ] KORL-PERFORMANCE-000-000-014: Vulkan; bandwidth: we don't actually need to submit this buffer right now!  It should be possible to maintain a command buffer for at least the duration of a frame (if not > 1 frame), and ONLY submit/flush the commands once any of the following conditions are met:  (1) the staging asset buffer fills up (2) we reach the end of the frame & the staging asset buffer is NOT empty
[ ] KORL-PERFORMANCE-000-000-015: Vulkan; we're shoving all the descriptors necessary for our batch rendering into a single descriptor set, but it's likely that some of the descriptors will have to change much more frequently during a frame, ergo, it is likely that splitting this descriptor set layout into multiple, and consequently having multiple descriptor sets for batch rendering per frame, will end up being more efficient
[ ] KORL-PERFORMANCE-000-000-016: Vulkan; speed: this is stupid & obviously slow; consider storing texture assets in a fixed-size table, allowing constant time lookups for each handle
[ ] KORL-PERFORMANCE-000-000-017: GFX; separate batch capacity with batch vertex/index counts themselves, allowing us to perform less reallocations (assuming this ever becomes a perf issue)
[ ] KORL-PERFORMANCE-000-000-018: GFX; (MINOR) use triangle fan primitive for less vertex indices
[ ] KORL-FEATURE-000-000-000: add vectored exception handler so we can generate crash dumps & flush logs
[ ] KORL-FEATURE-000-000-001: GFX: add support for outlined geometry (requires refactoring this API to use >= 1 sub-batches per Batch)
[ ] KORL-FEATURE-000-000-002: GFX: add support for outlined text (not sure how to do this with stbtt, maybe check how other implementations do this?)
[ ] KORL-FEATURE-000-000-003: interface-game-memory, memory: IMPORTANT!!!  Create the concept of "allocation handles" that come from korl-memory allocators.  This will allow us to effectively store pointers to dynamically allocated memory which can persist between game/application "states"!  Without this, we would not be able to easily implement save/load state features, which in turn will prevent us from having the ideal of "true" memory dumps, which can be generated at the beginning of each frame, saved when the application crashes, & loaded at another time on another computer for debug analysis.
