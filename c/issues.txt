[x] KORL-ISSUE-000-000-000: lazy load asset if KORL_ASSETCACHE_GET_FLAG_LAZY is specified
[x] KORL-ISSUE-000-000-001: only assert that the file loaded when we're not lazy loading
[x] KORL-ISSUE-000-000-002: VERY primitive implementation of `isVisibleCharacter`; we should just be using stbtt_IsGlyphEmpty for this purpose
[x] KORL-ISSUE-000-000-003: robustness: this is the "quick & dirty" stbtt API, ergo it's probably a good idea to switch to the lower-level API to be able to do things like lazy glyph caching, better packing, outlines, etc...
[ ] KORL-ISSUE-000-000-004: maybe change the scissor parameters to be an integral data type, since at some point a rounding strategy must occur anyways, and this information is obscured by this API, just for the sake of making it easier to call with f32 data... Which, I don't know if that's a great tradeoff honestly.
[ ] KORL-ISSUE-000-000-005: simplify: is it possible to just have a "createRectangle" function, and then add texture or color components to it in later calls?  And if so, is this API good (benefits/detriments to usability/readability/performance?)? My initial thoughts on this are: (1) this would introduce unnecessary performance penalties since we cannot know ahead of time what memory to allocate for the batch (whether or not we need UVs, colors, etc.) (2) the resulting API might become more complex anyways, and increase friction for the user
[ ] KORL-ISSUE-000-000-006: switch to use of a strong hash function instead of pointer
[ ] KORL-ISSUE-000-000-007: do we need to reassign the order of the widgets for the current window?  I wont bother with this until I learn a little bit about API usage...
[ ] KORL-ISSUE-000-000-008: instead of using the AABB of this text batch, we should be using the font's metrics!  Probably??  Different text batches of the same font will yield different sizes here, which will cause widget sizes to vary...
[ ] KORL-ISSUE-000-000-009: I have no idea why, but the Vulkan renderer is not drawing the upper-left corner of the window border correctly, so the first line's x-coordinate is offset by a half pixel
[x] KORL-ISSUE-000-000-010: memory allocator API: we don't actually need to expose ANY of this allocator API right now for any reason - all the user of this module needs is the enumeration of what kind of allocator they are getting, then the dispatch can just all be done internally and the user doesn't have to deal with function pointer crap.  In addition, we do NOT want the application storing any pointers!  We want to just store a handle to an allocator which is managed by the OS layer!
[x] KORL-ISSUE-000-000-011: simplify: make some macros which automatically inject file + line for calls to these allocator functions so we don't have to think about it
[ ] KORL-ISSUE-000-000-012: add a cleanup function to verify that there are not memory leaks
[x] KORL-ISSUE-000-000-013: add blend equations
[ ] KORL-ISSUE-000-000-014: move everything below this point into \c _Korl_Vulkan_SurfaceContext ???
[ ] KORL-ISSUE-000-000-015: store a collection of shader modules which can be referenced by external API, and store built-in shaders in known positions
[ ] KORL-ISSUE-000-000-016: robustness: use KORL_MEMORY_POOL_* API, or something similar
[ ] KORL-ISSUE-000-000-017: do we REALLY not need device-local memory for this?  I don't trust the tutorial writer(s) about this.  Maybe this can be probed at some point.
[ ] KORL-ISSUE-000-000-018: I'm not actually making use of this state anywhere at the moment, so this is currently useless.
[ ] KORL-ISSUE-000-000-019: Vulkan; HACK: this is a really stupid way of making sure the allocator can handle depth image buffers.  Instead of doing it this way, we should have some way of iterating over all possible format combinations which could potentially be used with this allocator and create a dummy image for each combination.  If we don't remove this hack, we will always be limited to just one type of image buffer per allocator!
[ ] KORL-ISSUE-000-000-020: Vulkan; robustness: ensure that device objects respect `bufferImageGranularity`, obtained from `VkPhysicalDeviceLimits`, if we ever have NON-LINEAR device objects in the same allocation (in addition to respecting memory alignment requirements, of course).
[ ] KORL-ISSUE-000-000-021: polymorphic-tagged-union; We essentially need "virtual constructor/destructor" logic for this data type, since this logic is specific to the device object type (we need to use different Vulkan API for these tasks).It's worth noting that I have found this to be a common enough design pattern that at one point I created a simple C++ parser which automatically generated dispatch routines for virtual functions (kcpp?), which theoretically might make development of these constructs easier.  Although, I am not yet _entirely_ convinced that this is the case just yet.  Generated v-tables are not a panacea, and still don't properly solve issues associated with function pointer tables, such as hot code reloading, so such a feature might need a bit more effort to make it easy-to-use like C++ virtuals, but also not complete shit under the hood that we can't fix (like C++ virtuals).
[ ] KORL-ISSUE-000-000-022: add support for memory allocators to decommit pages which are no longer in use
[ ] KORL-ISSUE-000-000-023: add support for memory allocators to defragment pages.  This will probably require some kind of specialized API that calls back to the user of the allocator so that they can decide what to do with each allocation, since this behavior would be implementation-specific.  For example, if the allocator user is storing objects that have pointers (god help us) or something, they will need to manually re-assign them to the new de-fragmented values.
[ ] KORL-ISSUE-000-000-024: Vulkan; robustness: cross-check this list of extension names with the extensionProperties queried above to check if they are all provided by the platform
[ ] KORL-ISSUE-000-000-025: Vulkan; re-record command buffers?... (waste of time probably)
[x] KORL-ISSUE-000-000-026: consistency: rename to Korl_Vulkan_Color3u8
[ ] KORL-ISSUE-000-000-027: Vulkan; feature: add shader/pipeline resource API
[x] KORL-ISSUE-000-000-028: In the case that we're deploying this application (not running in a debugger) maybe do one or more of the following things: (1) offer a choice to continue execution (2) offer a choice to write a memory dump to disk
[ ] KORL-ISSUE-000-000-029: pull out platform-agnostic code from platform-specific code module
[ ] KORL-ISSUE-000-000-030: redundant: technically we don't need this, since we can just call QueryVirtualMemoryInformation
[ ] KORL-ISSUE-000-000-031: copypasta: same code that runs in the `done` label (not sure if there is a good way to take this out though)
[x] KORL-ISSUE-000-000-032: safety: ensure that the thread calling this function is the main thread to ensure that the function pointers of the Korl_Memory_Allocator will always be valid, since the main program module (should) never be reloaded
[x] KORL-ISSUE-000-000-033: do we actually need `strsafe.h`?  This API seems to suck ass compared to the stuff it supposedly "replaced", such as \c _vscwprintf & \c vswprintf_s
[ ] KORL-ISSUE-000-000-034: investigate: WM_PAINT, ValidateRect(hWnd, NULL); ???  I'm not actually sure if this is necessary, so maybe this is very low priority.
[x] KORL-ISSUE-000-000-035: hack: delete this scaffolding once we have application/KORL separation at the project level
[~] KORL-ISSUE-000-000-036: (low priority) configure STB libs to not link to standard libraries at some point?  This should give us better stability & help clean up our application symbols in general
[x] KORL-ISSUE-000-000-037: remove C++20 flag from compile when game module is separate translation unit
[x] KORL-ISSUE-000-000-038: GUI: text AABBs are not being calculated correctly.  Example: try making a text widget that displays "[E][S][D][F]".  Observed behavior: the calculated AABB includes nothing below the text baseline it seems?...
[x] KORL-ISSUE-000-000-039: GUI: text AABBs are not being calculated correctly.  Example: make a text widget with just hashes ("---------") above & below other text widgets.  Expected behavior: whitespace above & below the hash characters.  Observed behavior: font metrics are not taken into account; no whitespace is taken into account for spacing between the widgets.
[ ] KORL-ISSUE-000-000-040: interface-game-memory: because this file is included in the platform's C translation unit, we can't declare/define any C++ datatypes here (such as classes).  Is this something to be concerned about?...
[x] KORL-ISSUE-000-000-041: build: remove exception handling code generation from platform translation unit, once the game translation unit is separated
[x] KORL-ISSUE-000-000-042: fix the issue with all the %s formatted strings being WRONG in the platform layer!!! (excluding: **\stb, submodules/korl/code)  I'm not sure what caused this, but I should probably finish the log refactor branch first before fixing this issue...
[x] KORL-ISSUE-000-000-043: memory: when allocations fail, log a warning & return NULL instead of failing an assert
[x] KORL-ISSUE-000-000-044: build: for deployments, consider using /ZH:SHA_256 to generate more robust PDB hashes
[x] KORL-ISSUE-000-000-045: windows: pass window focus state to game module; https://stackoverflow.com/a/466372
[ ] KORL-ISSUE-000-000-046: log: test to validate order of async log writes; we may or may not need to specify the offset to begin writing to the file for each async call, but I'm not sure.  See: https://stackoverflow.com/a/31787459
[x] KORL-ISSUE-000-000-047: build: separate game & platform module translation units into their own commands to allow separate compilation options & potentially multithreaded builds
[x] KORL-ISSUE-000-000-048: build: configure "release" build mode to test more optimized code, so we can actually benchmark stuff
[ ] KORL-ISSUE-000-000-049: memory: logging an error when allocation fails in log module results in poor error logging
[ ] KORL-ISSUE-000-000-050: time: make time probe API thread-safe
[x] KORL-ISSUE-000-000-051: countFormatSubstitutions: take precision '*' into account
[ ] KORL-ISSUE-000-000-052: log: potentially unnecessary allocator; unfortunately, due to how primitive linear allocators are, we can't throw all the allocations we're doing into the same allocator because when the big log circular buffer reallocs, the transient buffers (used for async file I/O, etc) will continuously push the big buffer higher up, further fragmenting memory until we run out of space!  To use a single allocator, we need to either add allocator defragmentation capabilities or implement a better realloc strategy that can look backwards as well as forwards (perhaps as a different allocator type?)
[x] KORL-ISSUE-000-000-053: memory: allow this API to work on other threads (IMPORTANT: this might be needed for log module!)
[ ] KORL-ISSUE-000-000-054: file: I think we need to put a lock around context->asyncPool operations, since it is possible for multiple threads to attempt to read/write to this data simultaneously
[x] KORL-ISSUE-000-000-055: file: deprecate this API because it sucks; _korl_file_getPath seems so much better
[x] KORL-ISSUE-000-000-056: assert: this code is extremely similar to code inside of korl-crash; maybe merge korl-assert into korl-crash?
[ ] KORL-ISSUE-000-000-057: file: initialization occurs before korl_crash_initialize, despite calling korl_assert & korl_log(ERROR)
[x] KORL-ISSUE-000-000-058: math: F32_MIN doesn't seem right
[-] KORL-ISSUE-000-000-059: window: find a frame timing solution that works if vulkan API blocks for some reason; on my machine at least, this ONLY works correctly for VK_PRESENT_MODE_MAILBOX_KHR present mode (apparently this is no longer an issue after updating my NVIDIA drivers...)
[ ] KORL-ISSUE-000-000-060: Vulkan: test & verify driver version decoding on Intel+Windows; I only saw this code posted somewhere online, and I haven't actually tested it on real intel hardware
[-] KORL-ISSUE-000-000-061: crash: we don't have to generate an exception to create a minidump (but actually, according to MSDN at least, this is a valid strategy to at least guarantee a readable stack state in the resulting minidump)
[ ] KORL-ISSUE-000-000-062: crash: minidump memory optimization/focus; this dump type results in HUGE dump files; is it possible to supply only a custom subset of memory regions to the dump?  I have tried MiniDumpWithPrivateReadWriteMemory, which seems to create smaller dumps, but sometimes the call to MiniDumpWriteDump fails, seemingly at random.  The MiniDumpWriteDump API seems to suggest that it is possible for the user to provide specific memory to include in the dump, which sounds pretty close to the ideal solution since we are managing almost all of our own memory, but I need to experiment a bit here to see if this is even possible.
[ ] KORL-ISSUE-000-000-063: crash: running MessageBox on the same thread as the the game window still allows window messages to be processed, causing all sorts of shenanigans to occur; is there a way to display a user interface like this without giving any other code on the failed process to run?  My ideal solution would be to somehow pause all activity on all threads when an unhandled/illegal exception is caught, and maybe running the dialog box on another process or something so that it can't interfere with the contaminated process state.  Raymond Chen with an example of using "toolhelp snapshots": https://devblogs.microsoft.com/oldnewthing/20060223-14/?p=32173; would this be useful in resolving this issue?
[ ] KORL-ISSUE-000-000-064: Vulkan: get rid of WIP frames? https://www.reddit.com/r/vulkan/comments/pq2679/understanding_queuing_multiple_frames_at_a_time/
[ ] KORL-ISSUE-000-000-065: log: although this is generally safe for current workloads, this operation is unsafe for async log file writes
[ ] KORL-ISSUE-000-000-066: memory: sort report allocations by ascending address
[ ] KORL-ISSUE-000-000-067: load-save-state: allocation file name not supported; when re-creating savestate allocations, we cannot specify the file name, because these are just stored in the allocators as a shallow address (we do not do a deep copy of the file name string!)
[ ] KORL-ISSUE-000-000-068: window: maybe expose more general API for doing things like save/load states & generate profiling reports
[ ] KORL-ISSUE-000-000-069: savestate/file: contain filesystem API to korl-file?
[ ] KORL-ISSUE-000-000-070: gfx/fontCache: Either cache glyphs dynamically instead of a fixed region all at once, or devise some way to configure the pre-cached range.
[ ] KORL-ISSUE-000-000-071: vulkan-memory: linear allocation addresses are vulnerable to fragmentation; if we continuously allocate device memory objects, we will quickly run out of addresses!  perhaps we can recycle unused device memory addresses in the allocate functions?
[ ] KORL-ISSUE-000-000-072: gfx/fontCache: glyph outlines don't utilize f32 accuracy of the outline thickness parameter; this also results in the glyph outlines always having a harsh (aliased) edge!
[ ] KORL-ISSUE-000-000-073: gui: widgets do not get ordered properly when they do not get "created" each frame; the recreated widget will get put at the bottom of the window's list of widgets, when the expected behavior is for the widgets to maintain the exact same order as they were created
[ ] KORL-ISSUE-000-000-074: sort submodule: replace CRT calls with configurable macros
[ ] KORL-ISSUE-000-000-075: log: dump log buffer to debugger if configured to output logs to debugger
[ ] KORL-ISSUE-000-000-076: file: replace working with raw writable UTF-16 pointers, we need codepoint iteration/get/set API
[ ] KORL-ISSUE-000-000-077: crash/window: savestates do not properly "save" crashes that occur inside game module callbacks on window events; because we are not (de)serializing window events
[ ] KORL-ISSUE-000-000-078: prevent windows from going to sleep with no input; https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadexecutionstate?redirectedfrom=MSDN
[ ] KORL-ISSUE-000-000-079: stringPool/file/savestate: either create a (de)serialization API for stringPool, or just put context state into a single allocation?  Although, why am I trying to push towards supporting fully properly "packed" savestate binary data anyways?  Since this mechanism inherently relies on raw memory copies, we will never be able to support cross-memory-architecture anyways, so all the effort spent to properly "pack" data into savestates is wasted...
[ ] KORL-ISSUE-000-000-080: memory: _korl_memory_allocator_linear_enumerateAllocations can't properly early-out if the enumeration callback returns false
[ ] KORL-ISSUE-000-000-081: savestate: weak/bad assumption; we currently rely on the fact that korl memory allocator handles remain the same between sessions.  Loading a savestate takes less logic, but the gain in performance/simplicity is negligible.  I would much rather have robust logic that is more guaranteed to assign the correct memory allocator handles (allocator handle (de)serialization)
[ ] KORL-PERFORMANCE-000-000-000: (minor) these pointers all reference contiguous memory regions which immediately follow this struct itself, ergo can be converted to offsets, saving us space but making the code less readable
[ ] KORL-PERFORMANCE-000-000-001: gfx: inefficient texture upload process; okay, I'm making a decision to just do the stupid method of "expanding" the 1-channel A8-format bitmap generated by stbtt into a R8G8B8A8-format image buffer, sending it off to vulkan, then destroying the temp buffer.  I'm just going to do this because for now I know it will work, and we can just come back to this if we ever encounter any performance issues!
[ ] KORL-PERFORMANCE-000-000-002: memory: you will never have a texture & font asset at the same time, so we could potentially overload this to the same string pointer
[ ] KORL-PERFORMANCE-000-000-003: memory: once again, only used by text batches; create a PTU here to save space?
[ ] KORL-PERFORMANCE-000-000-004: speed: most likely there is a MUCH more efficient way to build a matrix using these parameters
[ ] KORL-PERFORMANCE-000-000-005: speed: once again, not doing the most efficient thing here, but until this causes actual performance issues IDGAF
[ ] KORL-PERFORMANCE-000-000-006: speed: could potentially just compile this out for "release" builds, but like who actually cares??  The performance gain from doing so is most likely not at all worth it for all I know.  PRE-MATURE OPT!
[ ] KORL-PERFORMANCE-000-000-007: speed: comparisons between asset strings are going to be slow, so maybe we should create a hash table for asset identifiers at some point.  simple hash functions:  http://www.cse.yorku.ca/~oz/hash.html
[x] KORL-PERFORMANCE-000-000-008: even if we do end up needing to store the asset strings, it would likely be better if we store the strings in a separate string pool, and store a handle to that string here for faster iteration over device assets - we're wasting like an entire cache line per device asset lol
[ ] KORL-PERFORMANCE-000-000-009: pass model as push constant instead?  Timings required.
[ ] KORL-PERFORMANCE-000-000-010: pre-calculate the ViewProjection matrix; probably good for performance, but I would like to do timings for this
[ ] KORL-PERFORMANCE-000-000-011: Vulkan; setting createInfoSampler.maxAnisotropy to a lower value will trade off performance for quality
[ ] KORL-PERFORMANCE-000-000-012: Vulkan; bandwidth: (MAJOR!) this is very heavy handed!  It would be better if this process could happen in the background while we wait on a fence or something so that the graphicsQueue can keep going unimpeded and program execution can continue batching more vertices.
[ ] KORL-PERFORMANCE-000-000-013: Vulkan; speed: binding descriptor sets is an expensive operation, and it's likely that we will not need to do so each time the batch pipeline is flushed
[ ] KORL-PERFORMANCE-000-000-014: Vulkan; bandwidth: we don't actually need to submit this buffer right now!  It should be possible to maintain a command buffer for at least the duration of a frame (if not > 1 frame), and ONLY submit/flush the commands once any of the following conditions are met:  (1) the staging asset buffer fills up (2) we reach the end of the frame & the staging asset buffer is NOT empty
[ ] KORL-PERFORMANCE-000-000-015: Vulkan; we're shoving all the descriptors necessary for our batch rendering into a single descriptor set, but it's likely that some of the descriptors will have to change much more frequently during a frame, ergo, it is likely that splitting this descriptor set layout into multiple, and consequently having multiple descriptor sets for batch rendering per frame, will end up being more efficient
[ ] KORL-PERFORMANCE-000-000-016: Vulkan; speed: this is stupid & obviously slow; consider storing texture assets in a fixed-size table, allowing constant time lookups for each handle
[ ] KORL-PERFORMANCE-000-000-017: GFX; separate batch capacity with batch vertex/index counts themselves, allowing us to perform less reallocations (assuming this ever becomes a perf issue)
[ ] KORL-PERFORMANCE-000-000-018: GFX; (minor) use triangle fan primitive for less vertex indices
[x] KORL-PERFORMANCE-000-000-019: build: investigate potential benefits of running the platform/game translation units on separate threads
[x] KORL-PERFORMANCE-000-000-020: Vulkan: (MAJOR!) reduce batch descriptor set flush frequency; we should intelligently look at the last known state (for things like texture handle, etc) and ONLY flush batch descriptor sets if this changes, instead of ALWAYS flushing
[ ] KORL-PERFORMANCE-000-000-021: Vulkan: this is better than what we were doing before, but optimally we would have no wait during batchFlushStaging at all
[ ] KORL-PERFORMANCE-000-000-022: Vulkan: (minor) this function currently assumes that the caller is expecting to be able to safely write to the new staging buffer RIGHT AWAY, but in this special case we do NOT need to wait for the alternate staging buffer to be available!!!  We should add a parameter to this function to optionally ignore the `wait_for_new_buffer_fence` code that runs at the end of this function.
[ ] KORL-PERFORMANCE-000-000-023: Vulkan: (20us per iteration) likely suboptimal use of Vulkan synchronization primitives
[x] KORL-PERFORMANCE-000-000-024: Log: (likely MAJOR): Can we get away with just not doing any transient buffer allcations (just use the primary buffer + circular buffer)?  Currently, our Linear allocation strategy is heavy-handed, sacrificing speed for safety.  This is to the point that I've noticed individual allocations can take upwards of 20-40us.  This is fine for one-off allocations here and there, but logs are generated all over the place right now.  I highly suspect that this is the vast majority of time loss in places that are pumping out tons of logs, such as for time probe reports!
[ ] KORL-PERFORMANCE-000-000-025: stringPool: we should tell the allocation function that it doesn't have to sort
[ ] KORL-PERFORMANCE-000-000-026: savestate/assetCache: there is no need to save/load every asset; we only need assets that have been flagged as "operation critical" (where "operation critical" means that the asset data is required for correct application behavior given memory state & user inputs)
[ ] KORL-PERFORMANCE-000-000-027: memory: uncertain performance characteristics associated with re-committed pages; It is known that re-committing pages back and forth from the OS can be expensive.  An alternate strategy would be to give the OS a usage hint with VirtualAlloc(MEM_RESET), and conditionally zero the memory ourselves when we need to re-use this memory.  However, not even Raymond Chen knows whether or not this is faster:  https://devblogs.microsoft.com/oldnewthing/20170317-00/?p=95755.  That said, it can certainly be said that this technique is more complex, so I will leave this as performance research tech debt for now.
[ ] KORL-PERFORMANCE-000-000-028: memory: (likely extremely minor): _*general_enumerateAllocations: we should be able to skip more page flag registers immediately if we know we occupy 1 or more full registers
[ ] KORL-PERFORMANCE-000-000-029: memory: general allocator: occupiedPageOffset: Intuitively, I would assume that this code is just strictly sub-optimal, since we are just stupidly iterating over bit flags manually.  I feel like bitscans conducted on entire registers would be much more efficient.  However, I made an attempt at doing that here and either my code just sucks, or that technique was _actually_ sub-optimal (unlikely).  Alas, I am getting really sick of working on this code, so I am going to put this on the back-burner until performance ever becomes an issue in the future (if ever).
[x] KORL-FEATURE-000-000-000: add vectored exception handler so we can generate crash dumps & flush logs
[ ] KORL-FEATURE-000-000-001: GFX: add support for outlined geometry (requires refactoring this API to use >= 1 sub-batches per Batch)
[x] KORL-FEATURE-000-000-002: GFX: add support for outlined text (not sure how to do this with stbtt, maybe check how other implementations do this?)
[~] KORL-FEATURE-000-000-003: interface-game-memory, memory: IMPORTANT!!!  Create the concept of "allocation handles" that come from korl-memory allocators.  This will allow us to effectively store pointers to dynamically allocated memory which can persist between game/application "states"!  Without this, we would not be able to easily implement save/load state features, which in turn will prevent us from having the ideal of "true" memory dumps, which can be generated at the beginning of each frame, saved when the application crashes, & loaded at another time on another computer for debug analysis.  Well actually, now that I'm thinking about it, shouldn't this be fine?  Since our memory dumps will capture the entire state of the KORL allocators, including what range of virtual memory they occupy, it should be entirely possible to reconstruct the complete state of memory contained within the allocators, which in turn will place objects referred to by pointers at the exact location in memory that they orignally occupied!  Except, NO.  This does not account for tons of data that is contained in data segments of program memory.  Any pointers, or even data, held in this region are fucked if you load a save-state.  For example: in assetCache, we have a pool of AssetData, which in turn contain pointers to raw asset data buffers.  Not only will these data buffer pointers become invalid in a load-state scenario, but the database itself is subject to change - we do _not_ actually know what assets were loaded in the assetCache in the save-state!  After brainstorming a bit, I can't really think of a good way to do this without doing something dumb like hash table lookups, which seem completely unnecessary, so I'm just going to rectify this by individually serializing pointers & data outside of allocators on a case-by-case basis, and we'll just have to see how maintainable that is over time...
[ ] KORL-FEATURE-000-000-004: GUI: automatically save window positions/sizes to a config file, and load them on startup
[ ] KORL-FEATURE-000-000-005: GUI: allow user to call widget API & have a window automatically created for them
[x] KORL-FEATURE-000-000-006: save/load application state (REAL memory dumps)
[ ] KORL-FEATURE-000-000-007: dynamic resizing arrays, similar to stb_ds, but maybe configurable with a custom KORL allocator per array?
[ ] KORL-FEATURE-000-000-008: time: see if it's possible to use ETW in Windows to sample stack frames automatically for auto-generated profiling
[ ] KORL-FEATURE-000-000-009: time: display useful metrics in real-time using GUI or something
[ ] KORL-FEATURE-000-000-010: game: support automatic hot-reloading of entire code module
[x] KORL-FEATURE-000-000-011: math: add C++ API layer for operator overloading support
[ ] KORL-FEATURE-000-000-012: time: add C++ API layer for RAII time probe support
[x] KORL-FEATURE-000-000-013: time: report total time probe count in the report
[ ] KORL-FEATURE-000-000-014: time: allow the user to filter the report display somehow to reduce clutter; perhaps allow the user to configure a maximum reported probe depth?  Or perhaps make probe categories or something?
[ ] KORL-FEATURE-000-000-015: crash: detect infinite loops (unresponsive program)
[x] KORL-FEATURE-000-000-016: window: limit & regulate frame rate
[ ] KORL-FEATURE-000-000-017: time: add ability to stash reports for later consumption; avoids the issue of not being able to probe the report itself, among other things
[ ] KORL-FEATURE-000-000-018: GUI: add API to check if the GUI has input focus
[ ] KORL-FEATURE-000-000-019: window: automatically save window position/size to a config file, and load them on startup
[x] KORL-FEATURE-000-000-020: crash: dump savestate on crash
[x] KORL-FEATURE-000-000-021: assetCache: automatic hot-reloading of assets
[ ] KORL-FEATURE-000-000-022: add job queue + worker threads
[ ] KORL-FEATURE-000-000-023: support GLTF assets (meshes, materials, animations, etc...)
[ ] KORL-FEATURE-000-000-024: gui/gfx: add DPI-awareness & support
[ ] KORL-FEATURE-000-000-025: add gamepad support; Resources: https://github.com/MysteriousJ/Joystick-Input-Examples, http://gyrowiki.jibbsmart.com/blog:finding-gravity-with-sensor-fusion.  Desired device support: XBOX360, XBONE, DS3, DS4, SwitchPro.  Desired input support: buttons, axes, touchPad, gyro/accel(sensor-fusion API?).  Desired output support: force-feedback.
[ ] KORL-FEATURE-000-000-026: add "create new project" script
[ ] KORL-FEATURE-000-000-027: gui: display time probe metrics, in potentially an interactable way
[ ] KORL-FEATURE-000-000-028: gui: display memory metrics, in potentially an interactable way
[ ] KORL-FEATURE-000-000-029: add audio support; maybe use WASAPI & a mixer layer?  Desired support: WAVE files, OGG/Vorbis files.
[ ] KORL-FEATURE-000-000-030: 3D collision detection
[ ] KORL-FEATURE-000-000-031: UDP networking
[ ] KORL-FEATURE-000-000-032: create sample/example projects
[ ] KORL-FEATURE-000-000-033: add testbed scripts using samples/examples
[ ] KORL-FEATURE-000-000-034: memory: automatically save allocator addresses to a config file & load them on startup (in development builds only probably?...); this will potentially help development debugging times a LOT in the long run!
[ ] KORL-FEATURE-000-000-035: add support for SIMD instruction sets (maybe something common, like SSE | AVX).  Resources: https://stackoverflow.com/a/22521619/4526664 https://www.intel.com/content/dam/develop/external/us/en/documents/36945 (specifically chapter 2.2)
