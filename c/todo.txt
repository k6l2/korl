[x] log macro
	- INFO|DEBUG|ERROR
	- if we're in the VS debugger, use outputdebugstring
	- otherwise, just send to standard output streams
[x] create a script to compile all vulkan shaders in a project 
	(shader directory)
[x] dynamic memory allocation
	- use a macro to store the meta data of each allocation (file, line)
	- use allocation macro to align each specific allocation to its expected 
		alignment (using stdalign.h)
	- align allocations to pages
	- protect pages that are not allocated
	x if allocation fails, allocate another memory arena from the OS
	x if memory arena contains no allocations and is not the primary arena, 
		release the arena back to the OS
		- NO.  No memory arenas!  Just use mmap/VirtualAlloc!
	- stack allocator
	- heap allocator
	- is there a simple/easy way to have a common allocator "interface" which 
		essentially just a v-table dispatch?
[ ] memory metrics
	- how much memory is allocated for the ENTIRE program?
	- how much the allocated memory are we using?
	- WHERE do all our allocations originate?
	- report any memory leaks (without manually cleaning them up) just before 
	  execution of the program ends
[ ] time metrics
	- add thread to time metrics
	- "start" a time probe recording period (frames)
	- "probe" arbitrary sections of code using labels & using thread ID
	- print all the probe results from the previous frame
	- how does Optick get samples of the entire call stack of the application?
	- how does Optick get information about whether or not other applications on 
		the system are using the CPU at specific points in time?
[ ] stability metrics
	- SEH interceptor
	- stack overflow
	- infinite loop (unresponsive program) detection
[x] create a window
[ ] create a dynamic application code module
[x] gfx: vulkan - initialize graphics context
[x] gfx: vulkan - draw empty color buffer to the window
[ ] multi-threading: create a job queue + worker threads
[ ] assets: vulkan materials
	[ ] shader assets
	[ ] somehow draw mesh data using material pipeline?...
[x] gfx: vulkan - draw different geoprims (tris, lines)
[~] Sprite Fonts
	[x] dynamic memory: linear allocator
	[-] dynamic memory: stack allocator
		- push/pop
		- alloc
		- realloc
		- store meta data for each allocation right before the allocation memory pointer
			- bytes
			- file
			- line number
		- use OS virtual memory API directly to 
			- reserve a large range of addresses
			- commit only the necessary memory, then release when we're not using it anymore
	[x] assets: asset manager
		- we need this for loading graphics assets like shaders, textures, etc...
		- load assets from the current working directory
		- just use a stack allocator to store the asset data (always add memory, never remove free it)
	[x] assets: load PNG
	[x] gfx: vulkan - upload textures to GPU
	[x] gfx: vulkan - store & select from multiple uniform descriptor sets per frame
		- to support different VP matrices per frame
		- okay, NOW this feature actually works LUL
	[x] gfx: vulkan - draw textured geoprims
[x] gfx: vulkan: orthographic projection - for drawing HUDs
[x] gfx: vulkan: model transform for batch pipelines
[x] gfx: vulkan: depth buffer
[x] gfx: vulkan: optionally disable depth checking in render pipeline
[x] gfx: mesh generation abstraction; make drawing primitive meshes (quads, circles, etc) easier
	- motivation: we don't want to have to declare a bunch of vertex attribute 
		arrays and calculate them all individually each time we want to draw primitive meshes
	- similar to SFML shape classes API, but without the unnecessary OOP baggage
	[x] add a heap-controlled linear "stack" allocator whose contents are cleared
		at the beginning of each frame
[+] gfx: draw text
	[-] option: temporarily draw mesh font (stb_easy_font)
	[~] option: sprite font
	[+] option: TTF
		[+] TTF glyph cache
		[+] batch text using glyph cache asset
[x] gfx: dynamic scissor region for easier GUI rendering
[ ] immediate GUI
	[ ] OPTION: just build DearImGui w/ C bindings & link statically
	[ ] OPTION: DIY
		[ ] create a window
			[ ] begin API
			[ ] end API
			[ ] output geometry batches for all gui batches
			[ ] batch all the geometry batches; display window rectangle
		[ ] (un)focus window
			[ ] process OS mouse input events
			[ ] check if the user clicked on a window from the previous frame
			[ ] clicked nothing? => unfocus all windows
			[ ] clicked something? => set the window under the cursor to focus
				- process windows from front->back here so occluded windows get tested last
			[ ] when a window is focused:
				- change background color?
				- draw an outline?
		[ ] move window
			[ ] remember the last window we clicked on, as well as window-space position of the mouse cursor during the click
			[ ] if the mouse button is still down, we did click on a window, & we've moved a certain distance, then enter a `move-window` state
			[ ] if we're in the move window state, set the window position relative to the mouse cursor & the window-space click offset
		[ ] (un)focus multiple windows
			[ ] create >1 windows
			[ ] implement & test focus & movement for each of them running simultaneously
		[ ] add window title bar
			[ ] draw a c string for the window's title (overloading the unique address identifier for the igui window itself probably)
			[ ] assign a scissor region to the window's geometry batch, preventing the title bar text or anything else from drawing outside the window region (test this with a window title longer than the window size)
			[ ] prevent the window title bar from ever leaving the application viewport when being moved around, to prevent windows from becoming inaccessible
			[ ] use different color for title bar on focused windows
			[ ] add optional flags to window begin API to choose whether or not to use a title bar
		[ ] prevent windows that don't have a title bar from ever leaving the application viewport
		[ ] add text gui element
			[ ] begin API
			[ ] end API; probably able to overload this for _all_ gui elements
			- don't handle newlines; just render the text on a single line
		[ ] add window auto-size capability
			[ ] add optional flags to window begin API to specify this
			[ ] define a minimum window size to prevent creation of impossible to use windows
		[ ] add button gui element
			[ ] use the same logic as the text gui element, except add a rectangle to indicate mouse interaction state
			[ ] check if the mouse is hovering over any window from the previous frame
				- perfrom this check from front->back to maintain window Z-order
			[ ] hovered over a window? => propogate this event to the gui element unique to this location
				- for now, there is no such concept as a GUI DAG (gui elements containing other gui elements), so it's okay to just assume that each gui element in this window occupies a unique set of window coordinates
			[ ] onHovered for button gui element: highlight the button color
			[ ] onPressed for button gui element: (only if mouse cursor is still in the button) highlight the button a different color
			[ ] onRelease for button gui element: (only if mouse cursor is still in the button) set the state of the button to CLICKED
			[ ] at the end of each frame
				[ ] reset all the button guis PRESSED states if the mouse button is no longer pressed
				[ ] reset all the button guis CLICKED states
		[ ] add ability for windows (without auto-size style) to be resized
			[ ] onHovered near the window border: highlight the set of borders to be resized
			[ ] onPressed near the window border: highlight the set of borders to be resized in a different color
				[ ] if we JUST pressed, initialize the resize state
			[ ] onMoved (while in resize state): set the window position/size accordingly
			[ ] obey minimum window size, as defined in the window auto-size feature
		[ ] add ability for windows w/ title bar to collapse
			[ ] draw a little icon in the upper-right corner of title bar
			[ ] onHovered for the collapse button: highlight the button
			[ ] onPressed for the collapse button: (only if mouse cursor is still in the button) highlight the button in a different color
			[ ] onRelease for the collapse button: (only if mouse cursor is still in the button) toggle the collapse state for the window
		[ ] add variadic formatted text to the text gui element
		[ ] add horizontal scroll bars for windows
			- test with really long text gui elements
		[ ] add vertical scroll bars for windows
			- test with a window filled with a large # of text gui elements
		[ ] add ability to close windows w/ title bar
			[ ] draw close icon in upper-right
			[ ] onHovered for close button: highlight the button
			[ ] onPressed for close button: (only if mouse cursor is still in the button) highlight the button in a different color
			[ ] onRelease for close button: (only if mouse cursor is still in the button) close the window
[ ] keyboard input
[ ] mouse input
[ ] game pad input (XInput)
[ ] create sample project
[ ] build all sample projects
[ ] time metrics: draw graph of all probed threads
[ ] memory metrics: draw graph of all application memory usage
[ ] audio: stream output using WASAPI
[ ] assets: load WAV files
[ ] audio: mixer, play WAV assets
[ ] assets: load OggVorbis files
[ ] audio: play/loop OggVorbis assets
[ ] assets: load GLTF
[ ] gfx: vulkan - draw mesh
[ ] gfx: vulkan - animate mesh
[ ] collision detection (narrow-phase)
[ ] collision detection (manifold calculation)
[ ] collision resolution (???)
[ ] networking: UDP
[ ] networking: reliable packets
[ ] game pad input (RawInput)
	[ ] logitech pad (D mode)
	[ ] DS4
	[ ] DS3
[ ] prevent Windows from going to sleep with no user input
	https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadexecutionstate?redirectedfrom=MSDN
