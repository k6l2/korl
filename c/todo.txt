[x] log macro
	- INFO|DEBUG|ERROR
	- if we're in the VS debugger, use outputdebugstring
	- otherwise, just send to standard output streams
[x] create a script to compile all vulkan shaders in a project 
	(shader directory)
[x] dynamic memory allocation
	- use a macro to store the meta data of each allocation (file, line)
	- use allocation macro to align each specific allocation to its expected 
		alignment (using stdalign.h)
	- align allocations to pages
	- protect pages that are not allocated
	x if allocation fails, allocate another memory arena from the OS
	x if memory arena contains no allocations and is not the primary arena, 
		release the arena back to the OS
		- NO.  No memory arenas!  Just use mmap/VirtualAlloc!
	- stack allocator
	- heap allocator
	- is there a simple/easy way to have a common allocator "interface" which 
		essentially just a v-table dispatch?
[ ] memory metrics
	- how much memory is allocated for the ENTIRE program?
	- how much the allocated memory are we using?
	- WHERE do all our allocations originate?
	- report any memory leaks (without manually cleaning them up) just before 
	  execution of the program ends
[ ] time metrics
	- add thread to time metrics
	- "start" a time probe recording period (frames)
	- "probe" arbitrary sections of code using labels & using thread ID
	- print all the probe results from the previous frame
	- how does Optick get samples of the entire call stack of the application?
	- how does Optick get information about whether or not other applications on 
		the system are using the CPU at specific points in time?
[ ] stability metrics
	- SEH interceptor
	- stack overflow
	- infinite loop (unresponsive program) detection
[x] create a window
[ ] create a dynamic application code module
[x] gfx: vulkan - initialize graphics context
[x] gfx: vulkan - draw empty color buffer to the window
[ ] multi-threading: create a job queue + worker threads
[ ] assets: vulkan materials
	[ ] shader assets
	[ ] somehow draw mesh data using material pipeline?...
[x] gfx: vulkan - draw different geoprims (tris, lines)
[~] Sprite Fonts
	[x] dynamic memory: linear allocator
	[-] dynamic memory: stack allocator
		- push/pop
		- alloc
		- realloc
		- store meta data for each allocation right before the allocation memory pointer
			- bytes
			- file
			- line number
		- use OS virtual memory API directly to 
			- reserve a large range of addresses
			- commit only the necessary memory, then release when we're not using it anymore
	[x] assets: asset manager
		- we need this for loading graphics assets like shaders, textures, etc...
		- load assets from the current working directory
		- just use a stack allocator to store the asset data (always add memory, never remove free it)
	[x] assets: load PNG
	[x] gfx: vulkan - upload textures to GPU
	[x] gfx: vulkan - store & select from multiple uniform descriptor sets per frame
		- to support different VP matrices per frame
		- okay, NOW this feature actually works LUL
	[x] gfx: vulkan - draw textured geoprims
[x] gfx: vulkan: orthographic projection - for drawing HUDs
[x] gfx: vulkan: model transform for batch pipelines
[x] gfx: vulkan: depth buffer
[x] gfx: vulkan: optionally disable depth checking in render pipeline
[x] gfx: mesh generation abstraction; make drawing primitive meshes (quads, circles, etc) easier
	- motivation: we don't want to have to declare a bunch of vertex attribute 
		arrays and calculate them all individually each time we want to draw primitive meshes
	- similar to SFML shape classes API, but without the unnecessary OOP baggage
	[x] add a heap-controlled linear "stack" allocator whose contents are cleared
		at the beginning of each frame
[+] gfx: draw text
	[-] option: temporarily draw mesh font (stb_easy_font)
	[~] option: sprite font
	[+] option: TTF
		[+] TTF glyph cache
		[+] batch text using glyph cache asset
[x] gfx: dynamic scissor region for easier GUI rendering
[x] gfx: orthographic projection (non-fixed height, same dimensions as the swapchain)
[x] immediate GUI
	[-] OPTION: just build DearImGui w/ C bindings & link statically
		- naaaa, I'm going to just keep doing my own thing until I find that GUI API is too difficult and/or time-consuming
	[x] OPTION: DIY
		[x] create a window
			[x] begin API
			[x] end API
			[x] output geometry batches for all gui batches
			[x] batch all the geometry batches; display window rectangle
		[x] (un)focus window
			[x] process OS mouse input events
			[x] check if the user clicked on a window from the previous frame
			[x] clicked nothing? => unfocus all windows
			[x] clicked something? => set the window under the cursor to focus
				- process windows from front->back here so occluded windows get tested last
			[x] when a window is focused:
				- change background color?
				- draw an outline?
			[x] test with multiple windows
				- when a new window gets created, set its position to be offset relative to the top-level window
		[x] move window
			[x] remember the last window we clicked on, as well as window-space position of the mouse cursor during the click
			[-] if the mouse button is still down, we did click on a window, & we've moved a certain distance, then enter a `move-window` state
				- actually, now that I'm thinking about it, this is overly complex and unnecessary, so we can probably just only be able to move a window when the mouse-down event does NOT get captured by any widgets contained within
				- for now, since there are no widgets, if we mouse down in a window, we just immediately enter the "moving" state
			[x] if we're in the move window state, set the window position relative to the mouse cursor & the window-space click offset
		[x] add window title bar
			[x] draw a c string for the window's title (overloading the unique address identifier for the igui window itself probably)
			[x] assign a scissor region to the window's geometry batch, preventing the title bar text or anything else from drawing outside the window region (test this with a window title longer than the window size)
			[x] prevent the window title bar from ever leaving the application viewport when being moved around, to prevent windows from becoming inaccessible
			[x] use different color for title bar on focused windows
			[x] add optional flags to window begin API to choose whether or not to use a title bar
		[x] prevent windows that don't have a title bar from ever leaving the application viewport
		[x] add text gui element
			[x] begin API
			[-] end API; probably able to overload this for _all_ gui elements
			- don't handle newlines; just render the text on a single line
			- I also made this accept variadic args for formatted text!
		[x] add window auto-size capability
			[x] add optional flags to window begin API to specify this
			[x] define a minimum window size to prevent creation of impossible to use windows
		[x] add button gui element
			[x] use the same logic as the text gui element, except add a rectangle to indicate mouse interaction state
			[x] check if the mouse is hovering over any window from the previous frame
				- perfrom this check from front->back to maintain window Z-order
			[x] hovered over a window? => propogate this event to the gui element unique to this location
				- for now, there is no such concept as a GUI DAG (gui elements containing other gui elements), so it's okay to just assume that each gui element in this window occupies a unique set of window coordinates
			[x] onHovered for button gui element: highlight the button color
			[x] onPressed for button gui element: (only if mouse cursor is still in the button) highlight the button a different color
			[x] onRelease for button gui element: (only if mouse cursor is still in the button) set the state of the button to CLICKED
				- after considering this, I am going to accumulate button actuations in a counter instead of just a simple boolean state, since we are processing event-driven inputs; this allows us to process clicks CORRECTLY in the even that our frames are lagging for some reason
			[x] at the end of each frame
				[x] reset all the button guis PRESSED states if the mouse button is no longer pressed
				[x] reset all the button guis CLICKED states
		[x] add ability for windows (without auto-size style) to be resized
			[x] onHovered near the window border: highlight the set of borders to be resized
			[x] onPressed near the window border: highlight the set of borders to be resized in a different color
				[x] if we JUST pressed, initialize the resize state
			[x] onMoved (while in resize state): set the window position/size accordingly
			[x] obey minimum window size, as defined in the window auto-size feature
		[x] add ability to close windows w/ title bar
			[x] draw close icon in upper-right
			[x] onHovered for close button: highlight the button
			[x] onPressed for close button: (only if mouse cursor is still in the button) highlight the button in a different color
			[x] onRelease for close button: (only if mouse cursor is still in the button) close the window
		[x] change the color of window outline to be the resize color when the mouse is hovering over the top-level window
		[x] add ability for windows w/ title bar to collapse
			[x] draw a little icon in the upper-right corner of title bar
			[x] onHovered for the collapse button: highlight the button
			[x] onPressed for the collapse button: (only if mouse cursor is still in the button) highlight the button in a different color
			[x] onRelease for the collapse button: (only if mouse cursor is still in the button) toggle the collapse state for the window
			[x] collapse window contents when button is toggled
		[x] add horizontal scroll bars for windows
			[x] draw the scroll bar when window content is larger than the window's available content area
			[x] onHovered: highlight the scroll bar
			[x] onPressed: 
				[x] highlight in a different color
				[x] "activate" the scroll bar
			[x] onMove: (while pressed) adjust the scroll position appropriately
			[x] offset window drawn content according to scroll bar position
			[x] [shift]+mouse_scroll controls (only when hovering over this window)
			- test with really long text gui elements
		[x] add vertical scroll bars for windows
			[x] draw the scroll bar when window content is larger than the window's available content area
			[x] onHovered: highlight the scroll bar
			[x] onPressed: 
				[x] highlight in a different color
				[x] "activate" the scroll bar
			[x] onMove: (while pressed) adjust the scroll position appropriately
			[x] offset window drawn content according to scroll bar position
			[x] mouse_scroll controls (only when hovering over this window)
			- test with a window filled with a large # of text gui elements
		[x] draw outline around windows to make it easier to distinguish between overlapping windows
			- probably want to make this a batch of line primitives, so it's only a 1 pixel outline (we really don't need more than this...)
		[~] do we REALLY need API for korl_gui_windowEnd?  It doesn't really seem like it...
			- windows can automatically "end" when a new window is started
			- windows can automatically "end" when the gui frame ends
			- perhaps this API can just be optional?
			- if this API is optional, the following scanarios might become more annoyig:
				- populating gui windows with widgets from inside functions called between a window_begin/end block
				- attempting to call a widget function from outside a window_begin/end block, 
					assuming it is going to go to a dedicated "debug" window, 
					when in reality there just happened to be a dangling window_begin call somewhere
			- are any of the above scenarios really that bad?
				- not really...
			- on the other hand, is it really that bad to keep it required?
				- not really... also, less work to just leave it as required API... EH, maybe I'll just put this on the back burner
[ ] change KORL application subsystem from CONSOLE=>WINDOWS
	[ ] dump KORL logs to a file
		[ ] in development builds, immediately dump each log into the file without caring about file size
		[ ] in release builds, accumulate logs in a finite-sized circular buffer, and write them to a file when the program ends
		[ ] in either case, this process needs to be THREAD-SAFE!
	[ ] use korl-gui to display release build logs in real-time
		[ ] stop accumulating logs when the mouse hovers over the console
		[ ] implement text selection
		[ ] implement clipboard support (auto-copy text once it is selected)
		[ ] simplify: get rid of the log meta data tags
			[ ] change log line color based on log level
			[ ] click on log line to open the file which emitted it in a text editor (& preferably jump to the line number; is this possible?)
			[ ] change timestamp to be a millisend delta since the previous log timestamp
				[ ] only display timestamp when mouse is hovering over this log line?...
[ ] Windows: assume manual control over DPI-awareness
[ ] gui: gracefully scale graphics based on renderer DPI scale
[ ] keyboard input
[ ] mouse input
[ ] game pad input
	- just open devices directly using HID & RawInput APIs
	[ ] DS4
		[ ] USB protocol
			https://github.com/MysteriousJ/Joystick-Input-Examples
			[ ] binary inputs
			[ ] analog inputs
			[ ] touch pad inputs
			[ ] gyro/accel inputs
				http://gyrowiki.jibbsmart.com/blog:finding-gravity-with-sensor-fusion
				- perhaps we can just expose a "sensor fusion" input API to the user instead of just raw IMU inputs?...
			[ ] force-feedback output
		[ ] Bluetooth protocol
	[ ] XBOX360
	[ ] XBOX One
	[ ] DS3
[ ] create sample project
[ ] build all sample projects
[ ] time metrics: draw graph of all probed threads
[ ] memory metrics: draw graph of all application memory usage
[ ] audio: stream output using WASAPI
[ ] assets: load WAV files
[ ] audio: mixer, play WAV assets
[ ] assets: load OggVorbis files
[ ] audio: play/loop OggVorbis assets
[ ] assets: load GLTF
[ ] gfx: vulkan - draw mesh
[ ] gfx: vulkan - animate mesh
[ ] collision detection (narrow-phase)
[ ] collision detection (manifold calculation)
[ ] collision resolution (???)
[ ] networking: UDP
[ ] networking: reliable packets
[ ] prevent Windows from going to sleep with no user input
	https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadexecutionstate?redirectedfrom=MSDN
