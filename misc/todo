[x] Implement a simple OpenGL backend renderer API
	[x] draw primitives
		[x] draw lines so we can make an origin &| grid
		[x] draw triangles
	[x] manipulate the VIEW matrix
	[x] load textures (CPU => GPU)
	[x] draw textured triangles
	[x] allow some kind of `model` transform
[x] Implement a simple general-purpose allocator
[x] use general-purpose allocator for texture loading instead of raw 
	transient storage pointer inside of game
[x] figure out why the game shuts down sometimes when hot-reloading game code
[x] actually test kgaRealloc
[x] override assert & memory allocators for stb_image
[x] logging system 
	[x] circular buffer with maximum begin/end log lengths
	[x] selectable logging levels (info, error, warning)
	[x] automatically print file+line#
	[x] automatically print function name
	[x] automatically print a timestamp
	[x] write log to disk platform function
		[x] automatically write the log when the program exits gracefully
			https://www.gingerbill.org/article/2015/08/19/defer-in-cpp/
	[x] complete logging tech debt
		[x] fill in all the logging TODOs
		[x] remove ALL OutputDebugString calls and similar calls, replace w/ 
			logging calls
			[x] Allow game code to call platform log function.
[x] Logging system: perhaps fix the size of the log line meta tag to increase 
	readability, since source file name sizes tend to vary greatly
[x] Figure out why log file doesn't get output when running outside the 
	debugger...
	[x] remove LITERALLY all OutputDebugString calls for real this time??...
[x] detect when the program crashes 
	https://stackoverflow.com/q/19656946
	https://stackoverflow.com/q/28629351
	[x] write log file
	[x] write minidump file
[x] detect & properly handle stack overflows
	[x] reserve extra stack space for this case
		https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee?redirectedfrom=MSDN
[x] Obtain AppData folder specific to this application
[x] Obtain TempData folder specific to this application
[x] Write dump files to a global unified temp directory
[x] Write log files to temp directory instead of the application's exe directory
[x] Write game_temp dll file to temp directory instead of the application's exe 
	directory
[x] separate game code out of kml, and setup a different repo for a test game
[x] For the love of god remove assertions from logging code to prevent infinite 
	exceptions from firing...  Either that or make a better assert macro.
[x] Integrate IMGUI into the platform layer.
	[x] Hook IMGUI into the general-purpose allocator for transient storage.
		See IMGUI_DISABLE_DEFAULT_ALLOCATORS in `imconfig.h`
	[x] Figure out why ImGui isn't getting keyboard events :| :| :|
[x] Don't rebuild platform layer if none of the files have changed.
	Compare diff trees in batch? 
		https://www.dostips.com/forum/viewtopic.php?t=6223
[x] Copy the necessary .pdb files along side the mini dumps (if available) to
	minimize the chance of accidentally recompiling the pdbs!
	[x] copy win32-main.pdb
	[x] copy the latest version of game*.pdb
	[x] copy the actual application executable as well!!!
[x] perform the code tree diff in the build batch file separately for KML and 
	%project_dir%? (so that game projects can skip KML rebuilds and their own 
	code using separate conditions)
[x] Figure out why ImGui demo widget randomly crashes.  It seemed to crash
	when I had all the demo widgets open and then opened the console 
	example.
	[x] Is it my allocator that's broken???? (yes, yes it was)
		[x] track the total # of allocations in the KGeneralAllocator
			[x] verify double linked-list integrity in SLOW_BUILD mode
		[~] track the size of the largest unallocated chunk, if it exists...
		[~] WRITE UNIT TESTSSSSSSSSSS :(
		What other things can I verify??...
	[-] Does it only crash when called from game, or does win32-exe 
		experience the same crash?
[x] Load a WAV sound and play it.
	[x] Load entire WAV file into memory (temporary file memory pool).
		For the purposes of getting things up and running, this can just be 
	[x] Decode the WAV file format into a usable sound data structure.
	[x] Place this `RawSound` data into its final resting memory location 
		(game transient storage)
	[x] Encapsulate the memory location of the `RawSound` asset using an 
		`AssetHandle`
	[x] Create an AudioMixer state
		[x] Initialize with a set # of `TapeDeck`s, which holds a `Tape`
		[x] A `Tape` holds a reference to a RawSound, and how many samples of 
			the sound have been played so far.
	[x] Play a RawSound AssetHandle using the AudioMixer
		[x] Find an unused TapeDeck
		[x] If there is one, initialize the Tape using the AssetHandle to the 
			RawSound
		[x] Each frame in GAME_RENDER_AUDIO, pump the audioBuffer with data from 
			the AudioMixer
[x] Audio - Investigate `Failed to lock buffer! result=0x80070057` warning! :(
[x] Figure out a way to collapse the KLOG macros to relieve some of the 
	implementation burdon of the game module
[x] Audio Platform - decode OGG Vorbis files into RawSound using stb_vorbis
[x] Audio mixer - play+repeat forever
[x] Audio platform - go back to locking the maximum amount of the audio buffer;
	lock the entire range between [writeCursor, playCursor)
	[x] tell the audio mixer to fill as much of the buffer as possible with the 
		current tracks
	[x] calculate the # of consumed audio samples since last frame
	[x] change the track invalidation condition such that audio tracks only 
		become invalid when the audio platform has CONSUMED all of their audio 
		sample blocks (instead of becoming invalid as soon as all sample blocks 
		have been written to the buffer)
[x] Audio platform - fix buffer under-run when the application first starts due 
	to lag, etc...
[x] KAssetManager - load png files
[x] KRB - draw textured quad
[x] KRB: pass the API to the game module in a more graceful way to allow API 
	changes in a single file.
[x] KRB - modify model xform rotation
[x] Win32: Fix v-sync frame timing issues (not properly maintaining the target 
	frame rate)
[x] KRB - refactor API such that `KrbTextureHandle` is no longer required by 
	client code.  
	[-] Perhaps `KAssetManager` maintains a `KrbTextureHandle` alongside the 
		`RawImage`, which gets loaded into the KRB when the asset is added?
	[x] Perhaps `RawImage` just contains a `KrbTextureHandle` which simply gets 
		loaded into the KRB when the image gets loaded from the platform?
[x] Set where assets get loaded from locally at the platform level to remove the 
	need to continuously add "assets/" to the beginning of every asset string.
[x] Set kcpp output files to be read-only to reduce chance of accidentally 
	editing them instead of the original source files.
[x] move all the platform API calls into a PlatformApi struct.
[x] Asset streaming system (setup/prep)
	[x] Is there an easy way to bind asset names to code in an efficient way?
		Hashing asset strings everywhere is slow/cumbersome.
		[x] Maybe a meta-programming solution? 
			[x] How long does it take to read all the files inside of the 
				'/code' folder and write copies of all these files into 
				'/build/code' in the same folder structure???
				Answer: less than a second.
			[x] Or maybe just copy all source files into a temp code folder in 
				the build directory, performing the necessary token transforms 
				during this step.
			[x] Build a static database/manifest of asset strings in an array, 
				which  is included in source files that contain an instance of 
				the special macro.
			[x] Include the asset string manifest in all files that use KASSET 
				macro functionality. (automatically?)
			[~] Maybe sort the array of asset strings alphabetically for easier 
				debugging?
			[-] Output `*.gen.cpp` files for source files which contain replaced 
				asset strings.
			[-] Output `*.gen.cpp` files for source files which include files 
				which have been generated RECURSIVELY.
		[-] Maybe use X-Macro for this? https://stackoverflow.com/a/320888
			Scan thru code and replace a special empty macro with some value.
	[x] `push` request for an asset and receive an asset handle.
		[-] Quickly read file meta data to determine raw data size so we can 
			reserve it for whoever needs to load.
			(image dimensions, sound hz/#channels/bits-per-sample)
			PNG file spec: 
				http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html
			WAV file spec:
				http://soundfile.sapp.org/doc/WaveFormat/
		[x] push audio assets
		[x] push PNG assets
[x] multi-threaded job queue
	[x] spawn a bunch of threads
	[x] pull test jobs off a queue in a thread-safe manor
	[x] wait for all jobs to complete.
	[x] instead of burning a hole in my CPU, yield the threads to a semaphore 
		until work actually gets posted to the queue
	[x] generalize the queue to process any job
	[x] make log system thread-safe probably!
	https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread
	https://docs.microsoft.com/en-us/windows/win32/sync/semaphore-objects
	https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore?redirectedfrom=MSDN
	https://docs.microsoft.com/en-us/windows/win32/sync/wait-functions
[x] Asset streaming system (multi-threaded)
	[x] Load default assets when application first starts using Z85 files or 
		something
	[x] Until the asset is loaded into memory, the handle represents a default 
		asset of some kind. 
		(default texture, default mesh, default sound, etc...)
	[x] Submit a job to load pushed KASSET
	[x] make assetDataAllocator thread safe in the appropriate platform loading 
		functions.  (the allocator itself doesn't really have to be threadsafe)
		[x] Use a separate lock for vorbis operations
		[x] Make STBI allocations threadsafe
	[x] Fix KRB bug with glGetError not reporting all errors.
	[x] Fix KRB_BEGIN_FRAME bug where we pop too many matrices.
	[x] Query the platform layer for job completion status using a job handle.  
		This would eliminate the need to perform primitive synchronization 
		outside of the platform layer.
	[x] Free RawImage KRB resources when the asset gets freed
	[x] Query KAM for asset load status.  Use case: we don't want to perform 
		certain logic until all assets finish loading; if we're at a loading 
		screen or w/e.
[x] Hot-reload "active" assets when their date modified has changed.
[x] fix KRB not being correct when window resizes
[x] Win32: Fix mouse not displaying resize cursor
	Use the low-word of lParam of a WM_SETCURSOR message to determine what 
	cursor to use.
	https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-nchittest
[x] fullscreen toggle support 
	https://devblogs.microsoft.com/oldnewthing/20100412-00/?p=14353
[x] Fix keyboard buttonstates incorrect
	[x] differentiate between left/right alt keys
[x] Figure out why there is a beep when I press alt+enter
[x] "clean" build script
[x] "Release" build script
	[x] set appropriate code generation compiler options
	[x] Set win32 application icon.
	[x] Set win32 window icon.
	[x] procedurally set the asset load directory relative to the executable
	[x] automatically "clean" if requested debug/release selection differs from
		previous build's settings
	[x] If hiding the mouse cursor, only hide it if the cursor is inside the 
		client's rectangle; do not hide the mouse if we're in the window border!
[x] Attempt to separate the test "game" code from the rest of the platform 
	layer for the sake of organization.
	[-] kc++: apply code transformations on all included files?
		[-] How do you find where the included file is?
			We probably need the same build environment variable.
		[-] Process the included files.
		[-] Place them into the same directory as the transformed source file.  
			(ONLY if they have transformations applied!)
	[-] Refactor media layer code that contains code transformations so that it 
		no longer does so?
		[-] maybe KASSET macro expands to `assetCstr, kassetIndex`?
		[-] change KAssetManager API 
		[-] change KAudioMixer API
	[x] Just move KAssetManager & KAudioMixer out of the platform layer code &
		into the game layer code?
[x] Update README now that project is restructured, especially `new game 
	project` section.
[x] kc++: only include the generated kasset header ONCE per file!
	[x] Manually put an include macro at the top of files to help maintain line 
		#'s while debugging?
	[-] Automatically detect if we've already injected the include statement &
		ignore subsequent injections?
[x] KAU: change tape volume
[x] Flipbook sprites
	[x] Flipbook metadata KASSET
		[x] frame dimensions
		[x] frame count
		[x] texture asset file name
			[-] Is there a way to pre-compile this like KASSET filename strings?
			[x] Maybe we can just do a single pass over the g_kassets to convert 
				the asset filename into a KAssetCStr
		[x] default repeat?
		[x] default reverse?
		[x] default playback speed
	[x] Don't store the texture asset file name in FlipbookMetaData.  Instead, 
		store a KAssetCStr.  
	[x] Store a textureAssetFileName buffer inside KAsset in the KAM and pass a 
		reference to it to the platform.
	[x] default FlipbookMetaData KAsset
	[x] save the KAssetCStr into FlipbookMetaData KAsset
	[x] Add anchor ratio to flipbook meta data so we can correctly rotate the 
		flipbook's quad mesh.
	[x] Flipbook instance
		[x] repeat?
		[x] reverse?
		[x] playback speed
	[x] Draw Flipbook using KRB draw textured quad.
	[x] pass deltaSeconds to GAME_UPDATE_AND_DRAW
	[x] Update Flipbook based on deltaSeconds.
	[-] Create some sort of Flipbook manager construct which manages Flipbook 
		instances (using a handle/ticket system)???
		[-] Step all the Flipbook instances in the update function.
		[-] automatically change non-default Flipbook properties if the Flipbook 
			asset's values change (is this even necessary?)
	[x] hot-reload flipbook meta data assets
[x] Decide on whether or not I want this project to be `KML` or `KPL` or `KMPL` 
	or something else entirely?..
	[x] replace all appropriate strings in the project to the one I choose.
[x] generalAllocator => KGeneralAllocator
[x] KRB: draw circle
[x] Rebuild the game code if the KML code tree is changed, since game code 
	includes KML code and depends on it.
[x] kc++: Attempt to modify the input souce code IN-PLACE so when the compiler 
	builds the application, the debug files will point us back to the original 
	files instead of the read-only kc++ output code.
	[x] Rename the input source code directory (temporarily)
	[x] On top of outputing modified read-only source into a build directory, 
		also output regular files to the original source code directory's name.
	[x] In KML's build script: erase the modified code directory.
	[x] In KML's build script: rename the copied source directory back to the 
		original name
[x] Restructure GamePad similar to GameKeyboard to allow buttons to be iterated 
	over a loop.
[ ] KPL: `isApplicationFocused` functionality
	[ ] Don't quit application when ESC is pressed outside app focus!
[ ] Log: output milliseconds in timestamp
[ ] KAM: Fix asset->assetFileName memory becoming undefined after reloading game 
	code, which sometimes causes a crash on game code reload.
[ ] Figure out if there's a good way to include files from KML which need to be 
	processed by kc++ so that I don't have duplicate code in KML & individual 
	game folders.
	[ ] Option 1: dynamic recursive source inclusion
		[ ] Extract include directories from the %INCLUDE% environment variable
			http://www.cplusplus.com/reference/cstdlib/getenv/
		[ ] For each "include" directive found while processing our input code:
			[ ] Find the file using the %INCLUDE% directories 
			[ ] assert/fail if file isn't found
			[ ] check if the folder containing this file is already contained by 
				another added folder
			[ ] check if the folder contains other folders that were previously 
				added
		[ ] for each code folder that was added due to "include" directives:
			[ ] rename the folder temporarily
			[ ] create a folder with the same name and fill it with kcpp code!
		[ ] Problem: how does the build script know that this folder exists so 
			that we can delete the kcpp folders and rename the stashed code 
			folders?
	[ ] Option 2: special %KCPP_INCLUDE% environment variable
		[ ] extract all code directories from %KCPP_INCLUDE% 
		[ ] for each directory extracted:
			[ ] rename the folder temporarily
			[ ] create a folder with the same name and run kcpp on the original 
				code
		[ ] back in batch script, we can now restore the externally processed 
			kcpp code by extracting the directories from %KCPP_INCLUDE%
			https://stackoverflow.com/a/36432837
	[ ] Option 3: just run kc++ on all the %KCPP_INCLUDE% directories!
		[ ] extract all code directories from %KCPP_INCLUDE% in batch
		[ ] run kc++ on the directory, with read-only code output to our local 
			build directory as usual
		[ ] delete the kcpp code and rename the backup code folders for all the 
			%KCPP_INCLUDE% directories
[ ] kc++: release build
[ ] Do not poll async keyboard state if the window is not currently active.
[ ] KAU: master volume control, default to like ~80% or something...
[ ] Allow the game's build command to pass it's own .rc file to replace the one 
	provided by default from KML to allow the game to customize the application 
	icon
	[ ] Add a `Deployment Procedures` section to README to document this process
[ ] KRB: send vertex colors to draw functions.
	[ ] Maybe generalize KRB functions to take a pre-defined `Vertex` struct?..
[ ] KRB-opengl: Figure out why GL_UNSIGNED_INT_8_8_8_8 is undefined
	https://community.khronos.org/t/gl-unsigned-int-8-8-8-8-is-undefined/65686
[ ] Add a simple gameplay RNG utility with small well-defined state, like maybe 
	Wichmann–Hill for the memes since it was apparently used in Windwaker.
	https://en.wikipedia.org/wiki/List_of_random_number_generators
[ ] display debug frame metrics
	[ ] Can I just use Optick?..  I really liked Optick..
	[ ] allow the game code to probe the platform for cycle counts for timing.
	[ ] Investigate big ~10-frame lag spike that seems to happen every time the 
		application runs for ~30seconds after startup...
[ ] pause audio output when window goes out of focus probably.
[ ] Pay TODO debt.
[ ] Make asset streaming implementation more robust
	[ ] When attempting to load an asset and we're unable to allocate memory for 
		it...
		[ ] Ask platform to give us a new memory pool.
		[ ] If we are at maximum # of memory pools allowable, calculate the 
			oldest/least-used asset(s) and free them until we are able to 
			allocate successfully!
	[ ] Detect the condition where the allocator has enough space but is too 
		fragmented to place the asset.
		[ ] Attempt to de-fragment the asset memory pool.
		[ ] Release memory pools if they are emptied.
	[ ] We can eliminate the need for a platform-side lock on asset allocation 
		calls (or even allocation for that matter) by doing the thing where I 
		quickly read file data that tells me how big the raw asset is going to 
		be then returning immediately, allocating space for the data, then 
		asynchronously loading the rest of the file & decoding it into the 
		pre-allocated space.
[-] collision engine
	I should just do this on another repository, since this seems outside the 
	scope of a platform layer...
	https://www10.cs.fau.de/publications/theses/2010/Suenkel_BT_2010.pdf
[~] Disable asserts when `g_hasReceivedException` has been flagged, or else the 
	log file will never get written if an assert fires during the exception 
	handler!
	// I already have done this kinda in an earlier commit?..
[ ] turn on floating point exceptions
	https://docs.microsoft.com/en-us/windows/win32/debug/floating-point-exceptions
[ ] replace all ascii API calls with ambiguous char-width macros, and all CHAR 
	buffers with TCHARs to allow more flexibility & unicode support!!!  
	It's 2020.  We have infinite RAM.  Not supporting unicode is UNACCEPTABLE.
[ ] Compile KML with an abbreviated commit hash so that we can append this to 
	the mini dumps so we have a better idea of what codebase the crash happened 
	in, which will give more accurate source files.
	`git log -1 --pretty=format:%h`
[ ] Figure out if there is a good way to detect if an application was force-quit
	by the user, like in situations such as an infinite loop, or the application
	just generally taking too long to do something.
[ ] Automatically delete older minidumps once enough accumulate.
[ ] Give log files rolling file names like minidumps.
[ ] Automatically delete older log files once enough accumulate.
[ ] Platform audio: pause playback when window moving around.
[ ] Platform Audio - clean up the sound buffer when the program ends so there is
	no click artifact (if possible).
[ ] Audio Mixer - optimize `kauMix`
[ ] Move `KAsset.assetData.flipbook.textureAssetFileName` out of KAsset to keep 
	the size of KAsset as small as possible!
[ ] Detect how many worker threads to spawn based on how many logical cores are 
	available on the system.
[ ] Win32-KRB-opengl: Investigate the need to create a "proper context"
	https://www.khronos.org/opengl/wiki/Creating_an_OpenGL_Context_(WGL)#Proper_Context_Creation
[ ] Print GetLastError messages in human-readable format using FormatMessage
	https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
[ ] Job Queue - synchronize without locks (HERE BE DRAGONS I guess or something)
	https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming?redirectedfrom=MSDN#xbox-360-performance
	https://docs.microsoft.com/en-us/cpp/standard-library/atomic-functions?view=vs-2019#atomic_thread_fence
	https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedcompareexchange